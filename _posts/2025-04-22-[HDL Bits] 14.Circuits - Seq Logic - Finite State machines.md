---
title: "[HDL Bits] 14.Circuits - Seq Logic - Finite State Machines"
date: 2025-04-22 23:53:00 +09:00
categories: [Verilog, HDLbits]
tags:
  [
    verilog,
    HDLbits,
  ]
---

# HDL Bits 
HDLBits는 Verilog 하드웨어 설명 언어(HDL)를 사용하여 디지털 하드웨어 설계를 연습할 수 있는 소규모 회로 설계 연습 문제 모음입니다. 

문제가 주어지면 코드를 입력할 수 있고 바로 검증을 하여 맞고 틀렸는지 확인할 수 있습니다.
[HDL Bits](https://hdlbits.01xz.net/wiki/Main_Page)

# 3.2. Circuits 
Circuits 는 다음과 같은 목차로 구성되어 있습니다.
- Circuits
	- Combinational Logic
        - Basic Gates
        - Multiplexers
        - Arithmetic Circuits
        - Karnaugh Map to Circuit
    - Sequential Logic
        - Latches and Flip-Flops
        - Counters
        - Shift Registers
        - More Circuits
        - **Finite State Machines**
    - Building Larger Circuits
    
# 공지

오늘은 이 중 `Sequential Logic` 챕터의  `Finite State Machines` 를 풀어볼 예정입니다.

모든 문제의 난이도는 `주관적` 으로 설정하였습니다.

문제를 설명하거나 해결할 때 오타나 오류가 발생할 수 있습니다.

이를 참고해주시고 알려주시면 감사하겠습니다.

문제는 2025년 04월 11일에 다시 풀어보기 시작했으며 2025년 04월 22일 에 종료했습니다.

---

## 3.2.5.1. Simple FSM1(asynchronous reset) Fsm1
### Module Declaration
난이도: ★★☆☆☆
```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to state B
    input in,
    output out);//  

    parameter A=0, B=1; 
    reg state, next_state;

    always @(*) begin    // This is a combinational always block
        // State transition logic
    end

    always @(posedge clk, posedge areset) begin    // This is a sequential always block
        // State flip-flops with asynchronous reset
    end

    // Output logic
    // assign out = (state == ...);

endmodule

```

<br>

이번 문제는 2개의 상태, 하나의 입력, 하나의 출력을 가진 무어 상태 머신입니다.

<br>

```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to state B
    input in,
    output out);//  

    parameter A=1'b0, B=1'b1; 
    reg state, next_state;

    always @(*) begin    // This is a combinational always block
        case(state)
            B : if(in == 0) begin
                    next_state = A;
                end else begin
                    next_state = B;
                end
            // B : next_state <= in ? B : A;
            A : if(in == 0) begin
                    next_state = B;
                end else begin
                    next_state = A;
                end
            // A : next_state <= in ? A : B;
            default : next_state = B;
        endcase
    end

    always @(posedge clk, posedge areset) begin    
        if(areset) begin
            state <= B;
        end else begin
            state <= next_state;
        end
    end

    assign out =(state == B);


endmodule
```

<br>

## 3.2.5.2. Simple FSM 1 (synchronous reset) (Fsm1s)
### Module Declaration
난이도:  ★★★☆☆
```verilog
// Note the Verilog-1995 module declaration syntax here:
module top_module(clk, reset, in, out);
    input clk;
    input reset;    // Synchronous reset to state B
    input in;
    output out;//  
    reg out;

    // Fill in state name declarations

    reg present_state, next_state;

    always @(posedge clk) begin
        if (reset) begin  
            // Fill in reset logic
        end else begin
            case (present_state)
                // Fill in state transition logic
            endcase

            // State flip-flops
            present_state = next_state;   

            case (present_state)
                // Fill in output logic
            endcase
        end
    end

endmodule
```

<br>

이 문제는 두 가지 상태, 하나의 입력, 하나의 출력을 가진 무어 상태 기계입니다. 이 상태 기계를 구현합니다. 리셋 상태는 B입니다.

이 연습은 fsm1과 동일하지만 동기식 리셋을 사용합니다.

<br>

```verilog
// Note the Verilog-1995 module declaration syntax here:
module top_module(clk, reset, in, out);
    input clk;
    input reset;    // Synchronous reset to state B
    input in;
    output out;//  
    reg out;
    
    parameter A = 1'b0;
    parameter B = 1'b1;

    reg present_state, next_state;

    always @(posedge clk) begin
        if (reset) begin  
            present_state = B;
        end else begin
            case (present_state)
			    A : next_state = in ? A : B;
                B : next_state = in ? B : A;
                default : next_state = A;
            endcase

            present_state = next_state;   
        end
            case (present_state)
                A : out = 0;
                B : out = 1;
            endcase

    end

endmodule
```

<br>

이번 문제를 풀면서 시간을 많이 썼는데 그 이유가 예시로 나와있는 형식을 맞춰서 풀어보고 싶었고 계속 답이 나오지 않았기 때문에 시간이 오래걸렸습니다.

해결방법으로 단순하게 end 위치를 수정하여 분리를 하여 해결하였습니다.

<br>


## 3.2.5.3. Simple FSM2 (asynchronous reset) (Fsm2)
### Module Declaration
난이도:  ★★☆☆☆
```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF=0, ON=1; 
    reg state, next_state;

    always @(*) begin
        // State transition logic
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
    end

    // Output logic
    // assign out = (state == ...);

endmodule

```

<br>

이번 문제는 두 개의 상태, 두 개의 입력, 하나의 출력을 가진 무어 상태 머신입니다. 이 상태를 구현해보겠습니다.

<br>


```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF=1'b0, ON=1'b1; 
    reg state, next_state;

    always @(*) begin
    next_state = state;
        case(state) 
            OFF : next_state = j ? ON : OFF;
            ON : next_state = k ? OFF : ON;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        if(areset) begin
            state <= OFF;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == ON);

endmodule

```

<br>

## 3.2.5.4. Siymple FSM2 (synchronous reset) (Fsm2s)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF=0, ON=1; 
    reg state, next_state;

    always @(*) begin
        // State transition logic
    end

    always @(posedge clk) begin
        // State flip-flops with synchronous reset
    end

    // Output logic
    // assign out = (state == ...);

endmodule
```


<br>

이번 문제는 두 개의 상태, 두 개의 입력, 하나의 출력을 가진 무어 상태 머신입니다.

동기식 리셋을 사용합니다.

<br>

```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF= 1'b0, ON=1'b1; 
    reg state, next_state;

    always @(*) begin
        case(state)
            OFF : next_state =  j ? ON : OFF;
            ON  : next_state = k ? OFF : ON;
        endcase
    end

    always @(posedge clk) begin
        if(reset) begin
            state <= OFF;
        end else begin
            state <= next_state;
        end
    end
    // Output logic
    assign out = (state == ON);

endmodule
```

<br>


## 3.2.5.5. Simple state transitions3 (Fsm3comb)
### Module Declaration
난이도:  ★★☆☆☆
```verilog
module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)

    // Output logic:  out = f(state) for a Moore state machine

endmodule

```

<br>

이번 문제는 하나의 입력, 하나의 출력, 네 개의 상태를 가진 무어 상태 머신의 상태 전이표를 참고하여 해결합니다.

다음 상태의 인코딩을 사용합니다. (A=2'b00, B=2'b01, C=2'b10, D=2'b11)

이 상태 머신에 대해 상태 전이 논리와 출력 논리만 구현합니다.

현재 상태가 주어지면 상태 전이 테이블을 기반으로 다음 상태와 출력을 계산합니다.

<br>

| State | Next state (in=0) | Next state (in=1) | Output |
|-------|-------------------|-------------------|--------|
| A     | A                 | B                 | 0      |
| B     | C                 | B                 | 0      |
| C     | A                 | D                 | 0      |
| D     | C                 | B                 | 1      |


<br>

```verilog
module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    
    // State transition logic: next_state = f(state, in)

    wire [2:0] sel = {state,in};
    always@(*) begin
        case(sel) 
            3'b000 : next_state = A;  // 00 0 = A 
            3'b001 : next_state = B;  // 00 1 = B 
            3'b010 : next_state = C;  // 01 0 = B -> C 
            3'b011 : next_state = B;  // 01 1 = B -> B 
            3'b100 : next_state = A;  // 10 0 = C -> A 
            3'b101 : next_state = D;  // 10 1 = C -> D 
            3'b110 : next_state = C;  // 11 0 = D -> C
            3'b111 : next_state = B;  // 11 1 = D -> B
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D) ? 1'b1 : 1'b0;

endmodule
```

<br>

이번 문제는 예제에 써있는 주석을 보고 힌트를 얻어서 설계하였습니다.

물론 다음과 같이 설계하는 것이 더 짧습니다.

```verilog
    case (state)
        A: next_state = in ? B : A; 
        B: next_state = in ? B : C;
        C: next_state = in ? D : A;
        D: next_state = in ? B : C;
    endcase
```

<br>

하지만 `case문` 안에 조건들이 많아진다면 이 방법도 괜찮은 방법일 것 같습니다.

<br>


## 3.2.5.6. Simple one-hot state transitions 3 (Fsm3onehot)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = ...;
    assign next_state[B] = ...;
    assign next_state[C] = ...;
    assign next_state[D] = ...;

    // Output logic: 
    assign out = ...;

endmodule

```

<br>

이번 문제는 하나의 입력, 하나의 출력, 네 개의 상태를 가진 무어 상태 머신의 상태 전이표를 가지고 해결합니다.

다음과 같은 원 핫 상태 인코딩을 사용합니다. (A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000)

<br>

| State | Next state (in=0) | Next state (in=1) | Output |
|-------|-------------------|-------------------|--------|
| A     | A                 | B                 | 0      |
| B     | C                 | B                 | 0      |
| C     | A                 | D                 | 0      |
| D     | C                 | B                 | 1      |

<br>

검사을 통해 상태 전이 및 출력 논리 방적식을 도출합니다. 

이 상태 머신에는 상태 전이 논리와 출력 논리만 구현합니다.

RTL 수준의 설계를 위해 이 알고리즘을 알 필요는 없지만(논리 합성기가 이를 처리합니다), 원 핫 FSM이 더 간단한 논리를 가지는 이유를 설명할 수 있습니다(더 많은 상태 비트 저장을 희생하면서). 

<br>

```verilog
module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    //원핫 인코딩의 비트 위치를 의미

    assign next_state[A] = (state[C] & ~in) | (state[A] & ~in);
    // next_state[A] 는 in = 0 일 때 state A랑 C에서 도달합니다.
    assign next_state[B] = (state[A] & in) | (state[B] & in) | (state[D] & in);
    assign next_state[C] = (state[B] & ~in) |(state[D] & ~in);
    assign next_state[D] = (state[C] & in);

    assign out = (state[D]==1);

endmodule
```

<br>

#### 문제 비교
`3.4.5.5` 문제와 `3.4.5.6` 문제는 전체적은 구현은 동일합니다. 하지만 다음과 같은 차이점이 있습니다.

<br>

| **구분**          | **첫 번째 문제 (Binary Encoding)**     | **두 번째 문제 (One-Hot Encoding)**  |
|--------------------|-----------------------------------------|---------------------------------------|
| **상태 인코딩**    | 2비트 이진 (A=00, B=01, C=10, D=11)    | 4비트 원핫 (A=0001, B=0010, C=0100, D=1000) |
| **상태 전이 로직** | `case` 문을 사용한 직관적 구현         | 조합 논리식을 사용한 명시적 구현      |
| **출력 로직**      | 상태가 D일 때 `out=1` (Moore)          | 상태 D의 비트를 직접 확인 (Moore)     |
| **장점**           | 코드가 간결하고 가독성 높음            | 하드웨어 최적화에 유리                |
| **단점**           | 복잡한 상태 전이 시 확장성 낮음        | 비트 수가 많아 리소스 사용 증가       |

<br>

이 문제에서 주어진 파라미터는 4비트 원핫 인코딩의 비트 인덱스를 의미하며 활성화된 비트의 위치를 가리킵니다.

이를 8비트 원핫 인코딩으로 표현한다면 다음과 같습니다.

<br>

| **원핫 인코딩 (8비트)** | **활성화된 비트 위치** | **비트 인덱스 (3비트)** |
|--------------------------|------------------------|--------------------------|
| 8'b00000001             | 0번째 (LSB)           | 3'b000                  |
| 8'b00000010             | 1번째                 | 3'b001                  |
| 8'b00000100             | 2번째                 | 3'b010                  |
| 8'b00001000             | 3번째                 | 3'b011                  |
| 8'b00010000             | 4번째                 | 3'b100                  |
| 8'b00100000             | 5번째                 | 3'b101                  |
| 8'b01000000             | 6번째                 | 3'b110                  |
| 8'b10000000             | 7번째 (MSB)           | 3'b111                  |

<br>

## 3.2.5.7. Simple FSM 3 (asynchronous reset) (Fsm3)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input clk,
    input in,
    input areset,
    output out); //

    // State transition logic

    // State flip-flops with asynchronous reset

    // Output logic

endmodule

```

<br>

이번 문제는 하나의 입력, 하나의 출력, 네 개의 상태를 가진 무어 상태 머신의 상태 전이표를 가지고 해결합니다.

FSM을 상태 A로 재설정하는 비동기 리셋을 포함합니다.

<br>

```verilog
module top_module(
    input clk,
    input in,
    input areset,
    output out); //

    // State transition logic
    reg [1:0] state,n_state;
    
    parameter A = 2'b00, B = 2'b01, C = 2'b10, D =2'b11;
    
    always@(posedge clk, posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= n_state;
        end
    end

    always@(*) begin
        case(state) 
        A : n_state = in ? B : A;
        B : n_state = in ? B : C;
        C : n_state = in ? D : A;
        D : n_state = in ? B : C;
        endcase 
    end

    assign out = (state == D); 
endmodule
```

<br>

## 3.2.5.8. Simple FSM3 (Synchronous reset) (Fsm3s)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input clk,
    input in,
    input reset,
    output out); //

    // State transition logic

    // State flip-flops with synchronous reset

    // Output logic

endmodule

```

<br>

이번 문제도 위와 동일하지만 동기화리셋입니다.

<br>

```verilog
module top_module(
    input clk,
    input in,
    input reset,
    output out); //

    // State transition logic
    reg [1:0] state,n_state;
    
    parameter A = 2'b00, B = 2'b01, C = 2'b10, D =2'b11;
    
    always@(posedge clk) begin
        if(reset) begin
            state <= A;
        end else begin
            state <= n_state;
        end
    end

    always@(*) begin
        case(state) 
        A : n_state = in ? B : A;
        B : n_state = in ? B : C;
        C : n_state = in ? D : A;
        D : n_state = in ? B : C;
        endcase 
    end

    assign out = (state == D); 
endmodule
```

<br>

## 3.2.5.9. Design a Moor FSM (Exams/ece241 2013 q4)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

endmodule
```

<br>

이번 문제는 이미지를 참고해서 설계해야합니다.

**문제설명**

- 이 문제에서 대형 저수지는 여러 사용자에게 물을 공급합니다. 물의 수위를 충분히 높게 유지하기 위해서 3개의 센서가 수직으로 5인치 간격으로 배치됩니다.

- 물의 수위가 가장 높은 센서(`S3`)위에 있을 때 입력되는 유량은 `0` 이어야 합니다.

- 물의 수위가 가장 낮은 센서(`S1`)아래 있을 때, 유량은 최대로 설정됩니다.

- 물의 수위가 중간 (`S1` 과 `S3`사이)에 있을 때, 유량은 다음 두 가지 요인에 의해 결정됩니다.

    - 현재 물의 수위
    - 마지막 센서 변경 이전의 물 수위

**유량 제어 규칙**

1. 현재 물의 수위가 이전보다 낮아졌다면, 정상 흐름 밸브(`FR1`)를 활성화합니다.

2. 현재 물의 수위가 이전보다 높아졌다면, 보조 흐름 밸브(`ddf`)를 활성화하여 유량을 증가시킵니다.

**FSM 설계 요구 사항**

- 무어 상태 머신을 설계하여 저수지 컨트롤러를 구현합니다.

- 모든 상태 전이와 출력을 명확히 표시해야 합니다.

- 입력은 `S1`,`S2`,`S3` 이며 출력은 `FR1`,`FR2`,`FR3`,`DFR` 입니다.

**FSM 상태 정의**

| **상태**              | **센서 활성화 조건**   | **출력 (유량 제어)**         |
|-----------------------|-----------------------|-----------------------------|
| Above S3             | S1=1, S2=1, S3=1     | None                        |
| Between S3 and S2    | S1=1, S2=1, S3=0     | FR1                         |
| Between S2 and S1    | S1=1, S2=0, S3=0     | FR1, FR2                    |
| Below S1             | S1=0, S2=0, S3=0     | FR1, FR2, FR3,           |

<br>

또한 상태 머신을 오랫동안 수위가 낮았을 때와 동일한 상태로 재설정하는 Active-high 동기식 리셋(출력이 모두 어설트)를 포함하세요.

<br>

```verilog
module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

parameter Above_S3 = 2'b00;
parameter BetS3_S2 = 2'b01;
parameter BetS2_S1 = 2'b10;
parameter Below_S1 = 2'b11;

reg [1:0] state,n_state;

always@(posedge clk) begin 
    if(reset) begin
        state <= Below_S1;
    end else begin
        state <= n_state;
    end
end

always@(*) begin
    case(state) 
        Above_S3 : begin
            if(s[s]) begin
                n_state = Above_S3;
            end else if(s[2]) begin
                n_state = BetS3_S2;
            end else if(s[1]) begin
                n_state = BetS2_S1;
            end else begin
                n_state = Below_S1;
            end
        end

        BetS3_S2 : begin
            if(s[3]) begin
                n_state = Above_S3;
            end else if(s[2]) begin
                n_state = BetS3_S2;
            end else if(s[1]) begin
                n_state = BetS2_S1;
            end else begin
                n_state = Below_S1;
            end
        end

        BetS2_S1 : begin
            if(s[3]) begin
                n_state = Above_S3;
            end else if(s[2]) begin
                n_state = BetS3_S2;
            end else if(s[1]) begin
                n_state = BetS2_S1;
            end else begin
                n_state = Below_S1;
            end
        end

        Below_S1 : begin
            if(s[3]) begin
                n_state = Above_S3;
            end else if(s[2]) begin
                n_state = BetS3_S2;
            end else if(s[1]) begin
                n_state = BetS2_S1;
            end else begin
                n_state = Below_S1;
            end
        end
    endcase
end

always@(*) begin
    case(state) 
        Above_S3 : begin
            fr1 = 0;
            fr2 = 0;
            fr3 = 0;
        end

        BetS3_S2 : begin
            fr1 = 1;
            fr2 = 0;
            fr3 = 0;
        end

        BetS2_S1 : begin
            fr1 = 1;
            fr2 = 1;
            fr3 = 0;
        end

        Below_S1 : begin
            fr1 = 1;
            fr2 = 1;
            fr3 = 1;
        end

        default : begin
            fr1 = 0;
            fr2 = 0;
            fr3 = 0;
        end
    endcase

end

/*
assign fr1 = (state == BetS3_S2) || (state == BetS2_S1) || (state == Below_S1);
assign fr2 = (state == BetS2_S1) || (state == Below_S1);
assign fr3 = (state == Below_S1);
*/

always @(posedge clk ) begin
    if(reset) begin
        dfr <=1; 
    end else if(state > n_state)begin // 현재 수위가 다음 수위보다 높을때 -> 수위 감소 -> dfr  On
        dfr <=1;
    end else if(state < n_state)begin
        dfr <=0;
    end else
        dfr <=dfr;
end

endmodule
```

<br>

## 3.2.5.10. Lemmings 1 (Lemmings1)
### Module Declaration
난이도:  ★★☆☆☆
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    output walk_left,
    output walk_right); //  

    // parameter LEFT=0, RIGHT=1, ...
    reg state, next_state;

    always @(*) begin
        // State transition logic
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
    end

    // Output logic
    // assign walk_left = (state == ...);
    // assign walk_right = (state == ...);

endmodule

```

<br>

이번 문제는 게임을 제작하는 것입니다.

`Lemmings` 라는 게임은 비교적 단순한 두뇌를 가진 생물들이 등장합니다.

너무 간단해서 유한 상태 머신을 사용하여 모델링하려고 합니다.

레밍의 2D 세계에서 레밍은 왼쪽으로 걷는 상태와 오른쪽으로 걷는 상태 중 하나일 수 있습니다.

장애물에 부딪히면 방향을 전환합니다.

특히 레밍이 왼쪽에서 부딪히면 오른쪽으로 걷습니다. 오른쪽에서 부딪히면 왼쪽으로 걷습니다.

양쪽에서 동시에 부딪히면 뱡향을 전환합니다.

이 동작을 모델링하는 두 개의 상태, 두 개의 입력, 하나의 출력을 가진 무어 상태 머신을 구현합니다.


<br>

```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    output walk_left,
    output walk_right); //  

    parameter LEFT=1'b0, RIGHT=1'b1;
    reg state, next_state;

    always @(*) begin
    next_state = state;
        case(state) 
            LEFT :  begin
                if(bump_left) begin
                    next_state <= RIGHT;
                end else begin
                    next_state <= LEFT;
                end
            end

            RIGHT : begin
                if(bump_right) begin
                    next_state <= LEFT;
                end else begin
                    next_state <= RIGHT;
                end
            end

        endcase
    end

    always @(posedge clk, posedge areset) begin
        if(areset) begin
            state <= LEFT;
        end else begin
            state <= next_state;
        end
    end

    assign walk_left = (state == LEFT);
    assign walk_right = (state == RIGHT);

endmodule
```

<br>

## 3.2.5.11. Lemmings 2 (Lemmings2)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    output walk_left,
    output walk_right,
    output aaah ); 

endmodule
```

<br>

레밍스는 왼쪽과 오른쪽을 것는 것 외에도 그 아래로 사라지면 넘어질 것입니다. 

좌우로 걷다가 부딪혔을 때 방향을 바꾸는 것 외에도 `ground = 0`일 때 레밍족이 넘어지면서 "아아아!" 라고 말합니다.

지면이 다시 나타나면 (`ground = 1`), 레밍족은 넘어지기 전과 같은 방향으로 걷기를 재개합니다.

넘어지면서 부딪혔다고 해서 걷는 방향에 영향을 미치지 않으며 지면과 같은 주기로 부딪혔다고 해서 땅이 사라지거나(아직 떨어지지 않음), 혹은 땅에 떨어진 상태에서 다시 나타나면 걷는 방향에도 영향을 미치지 않습니다.

이 동작을 모델링 하는 유한 상태 머신을 만듭니다.

<br>

```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    output walk_left,
    output walk_right,
    output aaah ); 

    reg [1:0] state, n_state;
    parameter LEFT = 2'b00, RIGHT = 2'b01, LEFT_AH = 2'b10, RIGHT_AH = 2'b11; 


    always@(posedge clk, posedge areset) begin
        if(areset) begin
            state <= LEFT;
        end else begin
            state <= n_state;
        end
    end

    always@(*) begin
        case(state)
            LEFT : begin
                    if(ground) begin
                        if(bump_left) begin
                            n_state <= RIGHT;
                        end else if(bump_right) begin
                            n_state <= LEFT;
                        end else begin
                            n_state <= LEFT;
                        end 
                    end else begin
                        n_state <= LEFT_AH;
                    end 
            end

            RIGHT : begin
                    if(ground) begin
                        if(bump_right) begin
                            n_state <= LEFT;
                        end else if(bump_left) begin
                            n_state <= RIGHT;
                        end else begin
                            n_state <= RIGHT;
                        end
                    end else begin
                            n_state <= RIGHT_AH;
                    end
            end

            LEFT_AH : begin
                    if(ground) begin
                        n_state <= LEFT;
                    end else begin
                        n_state <= LEFT_AH;
                    end
            end


            RIGHT_AH : begin
                    if(ground) begin
                        n_state <= RIGHT;
                    end else begin
                        n_state <= RIGHT_AH;
                    end
            end
        endcase
    end

assign walk_left = (state == LEFT);
assign walk_right = (state == RIGHT);
assign aaah = (state == LEFT_AH || state == RIGHT_AH);

endmodule
```

<br>

## 3.2.5.12. Lemmings 3 (Lemmings3)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 

endmodule

```

<br>

레밍은 걷거나 넘어지는 것 외에도 가끔 땅 파기(`dig=1`일 때 땅 파기 시작)와 같은 유용한 일을 하도록 지시할 수 있습니다. 

레밍은 현재 땅 위를 걷고 있는 경우(`ground=1`이고 떨어지지 않는 경우) 땅을 파고 반대편에 도달할 때까지(`ground =0`) 계속 땅을 파게 됩니다. 

이때는 땅이 없으므로 넘어지고(`aaah!`), 다시 땅에 닿으면 원래 방향으로 계속 걷습니다.

넘어질 때와 마찬가지로 땅을 파다가 부딪혀도 아무런 영향이 없으며, 넘어질 때나 땅이 없을 때 땅을 파라는 지시는 무시됩니다.

(다시 말해, 걷는 레밍은 넘어지거나 땅을 파거나 방향을 바꿀 수 있습니다. 

이 조건 중 두 개 이상의 조건이 충족되면, 넘어짐이 파기보다 우선순위가 높으며, 이는 방향 전환보다 우선순위가 높습니다).

유한 상태 머신을 확장하여 이 동작을 모델링하세요.

<br>

```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 

reg [2:0] state ,n_state;

parameter LEFT =3'b000, LEFT_AH = 3'b001 , LEFT_DIG = 3'b010;
parameter RIGHT = 3'b011, RIGHT_AH = 3'b100, RIGHT_DIG = 3'b101;

    always@(posedge clk, posedge areset) begin
        if(areset) begin
            state <= LEFT; 
        end else begin 
            state <= n_state;
        end
    end 

    always@(*) begin
        case(state)
            LEFT : begin
                if(!ground) begin
                    n_state <= LEFT_AH;
                end else begin
                    if(dig) begin
                        n_state <= LEFT_DIG;
                    end else begin
                        if(bump_left) begin
                            n_state <= RIGHT;
                        end else begin
                            n_state <= LEFT;
                        end
                    end
                end

            end
            
            RIGHT : begin
                if(!ground) begin
                    n_state <= RIGHT_AH;
                end else begin
                    if(dig) begin
                        n_state <= RIGHT_DIG;
                    end else begin
                        if(bump_right) begin
                            n_state <= LEFT;
                        end else begin
                            n_state <= RIGHT;
                        end
                    end
                end

            end          


            LEFT_AH: begin
                if(ground) begin
                    n_state <= LEFT;
                end else begin
                    n_state <= LEFT_AH;
                end
            end

            RIGHT_AH: begin
                if(ground) begin
                    n_state <= RIGHT;
                end else begin
                    n_state <= RIGHT_AH;
                end
            end

            LEFT_DIG : begin
                if(ground) begin
                    n_state <= LEFT_DIG;
                end else begin
                    n_state <= LEFT_AH;
                end
            end


            RIGHT_DIG : begin
                if(ground) begin
                    n_state <= RIGHT_DIG;
                end else begin
                    n_state <= RIGHT_AH;
                end
            end
        
        endcase
    end

    assign walk_left = (state == LEFT);
    assign walk_right = (state == RIGHT);
    assign aaah = (state == LEFT_AH || state == RIGHT_AH);
    assign digging = (state == LEFT_DIG || state == RIGHT_DIG);

endmodule
```

<br>

## 3.2.5.13. Lemings4 (Lemmings4)
### Module Declaration
난이도:  ★★★★★
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 

endmodule
```

<br>

레밍은 걷고, 넘어지고, 땅을 파는 것이 가능하지만, 무적 상태는 아닙니다.

레밍이 너무 오래 떨어졌다가 땅에 닿으면 튈 수 있습니다. 

특히, 레밍이 20 클럭 사이클 이상 떨어진 후 땅에 닿으면 튀어서 영원히(또는 FSM이 초기화될 때까지) 걷기, 낙하, 땅 파기를 멈춥니다(4개의 출력이 모두 0이 됩니다). 

레밍이 땅에 닿기 전에 얼마나 멀리 떨어질 수 있는지에 대한 상한선은 없습니다. 레밍은 땅에 닿을 때만 튀어 오르며, 공중에서는 튀어 오르지 않습니다.

유한 상태 머신을 확장하여 이 동작을 모델링하세요.

20주기 동안 떨어지는 것은 생존할 수 있습니다:

<br>

```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 

reg [2:0] state ,n_state;

parameter LEFT =3'b000, LEFT_AH = 3'b001 , LEFT_DIG = 3'b010;
parameter RIGHT = 3'b011, RIGHT_AH = 3'b100, RIGHT_DIG = 3'b101;
parameter OOPS = 3'b110;

    always@(posedge clk, posedge areset) begin
        if(areset) begin
            state <= LEFT; 
        end else begin 
            state <= n_state;
        end
    end 

reg [7:0] cnt;

    always@(posedge clk, posedge areset) begin
        if(areset) begin
            cnt <= 0;
        end else if(state == RIGHT_AH || state == LEFT_AH) begin
            cnt <= cnt + 1'b1;
        end else begin
            cnt <= 0;
        end
    end



    always@(*) begin
    n_state = state;
        case(state)
            LEFT : begin
                if(!ground) begin
                    n_state <= LEFT_AH;
                end else begin
                    if(dig) begin
                        n_state <= LEFT_DIG;
                    end else begin
                        if(bump_left) begin
                            n_state <= RIGHT;
                        end else begin
                            n_state <= LEFT;
                        end
                    end
                end

            end
            
            RIGHT : begin
                if(!ground) begin
                    n_state <= RIGHT_AH;
                end else begin
                    if(dig) begin
                        n_state <= RIGHT_DIG;
                    end else begin
                        if(bump_right) begin
                            n_state <= LEFT;
                        end else begin
                            n_state <= RIGHT;
                        end
                    end
                end

            end          


            LEFT_AH: begin
                if(!ground) begin 
                    n_state <= LEFT_AH;
                end else begin
                    if(cnt >=20) begin
                        n_state <= OOPS;
                    end else begin
                        n_state <= LEFT;
                    end
                end
            end

            RIGHT_AH: begin
                if(!ground) begin 
                    n_state <= RIGHT_AH;
                end else begin
                    if(cnt >= 20) begin
                        n_state <= OOPS;
                    end else begin
                        n_state <= RIGHT;
                    end
                end
            end

            LEFT_DIG : begin
                if(ground) begin
                    n_state <= LEFT_DIG;
                end else begin
                    n_state <= LEFT_AH;
                end
            end


            RIGHT_DIG : begin
                if(ground) begin
                    n_state <= RIGHT_DIG;
                end else begin
                    n_state <= RIGHT_AH;
                end
            end

            OOPS : begin
                if(areset) begin
                    n_state <= LEFT;
                end else begin
                    n_state <= OOPS;
                end
            end 

        endcase
    end

    assign walk_left = (state == LEFT );
    assign walk_right = (state == RIGHT );
    assign aaah = ((state == LEFT_AH || state == RIGHT_AH) );
    assign digging = (state == LEFT_DIG || state == RIGHT_DIG);

endmodule
```

<br>

## 3.2.5.14. One-hot FSM (Fsm onehot)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module(
    input in,
    input [9:0] state,
    output [9:0] next_state,
    output out1,
    output out2);

endmodule
```

<br>

이 상태 머신은 원핫 인코딩을 사용하며, `state[0]`부터 `state[9]`까지가 각각 상태 S0부터 S9에 해당한다고 가정해 보겠습니다. 

출력은 달리 명시되지 않는 한 `0`입니다.

상태 머신의 상태 전환 로직과 출력 로직 부분을 구현합니다(상태 플립플롭은 구현하지 않음).

`state[9:0]`에 현재 상태가 주어지며, `next_state[9:0]`와 두 개의 출력을 생성해야 합니다. 

원핫 인코딩을 가정하여 검사를 통해 논리 방정식을 도출합니다. 
    
(테스트벤치는 더 복잡한 작업을 시도하고 있지 않은지 확인하기 위해 원핫이 아닌 입력으로 테스트합니다).

<br>

```verilog
module top_module(
    input in,
    input [9:0] state,
    output [9:0] next_state,
    output out1,
    output out2);

    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);
    assign next_state[1] = (state[0] & in) | (state[8] &in) | (state[9] & in);
    assign next_state[2] = state[1] & in;
    assign next_state[3] = state[2] & in;
    assign next_state[4] = state[3] & in;
    assign next_state[5] = state[4] & in;
    assign next_state[6] = state[5] & in;
    assign next_state[7] = (state[6] & in) | (state[7] & in);
    assign next_state[8] = state[5] & ~in;
    assign next_state[9] = state[6] & ~in;

    assign out1 = ((state[8]==1) | (state[9]==1));
    assign out2 = ((state[7]==1) | (state[9]==1));

endmodule
```

<br>

## 3.2.5.15. PS / 2 packet parser (FSM ps2)
### Module Declaration
난이도:  ★★★☆☆

```verilog
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    // State transition logic (combinational)

    // State flip-flops (sequential)
 
    // Output logic

endmodule

```

<br>

PS/2 마우스 프로토콜은 3바이트 길이의 메시지를 전송합니다. 

그러나 연속적인 바이트 스트림 내에서 메시지의 시작과 끝이 어디인지 명확하지 않습니다. 

각 3바이트 메시지의 첫 번째 바이트는 항상 bit[3]=1이라는 것만 알 수 있습니다(하지만 나머지 두 바이트의 bit[3]은 데이터에 따라 1 또는 0일 수 있습니다).

우리는 입력 바이트 스트림이 주어졌을 때 메시지 경계를 검색하는 유한 상태 머신을 원합니다. 

우리가 사용할 알고리즘은 비트[3]=1이 있는 바이트가 나타날 때까지 바이트들을 버리는 것입니다. 

그런 다음 이것이 메시지의 바이트 1이라고 가정하고 3바이트를 모두 수신하면 메시지 수신(완료) 신호를 보냅니다.

FSM은 각 메시지의 세 번째 바이트가 성공적으로 수신된 직후 사이클에서 완료 신호를 보내야 합니다

<br>

```verilog
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    reg [1:0] state, n_state;
    parameter Byte1 = 2'b00, Byte2 = 2'b01, Byte3 = 2'b10, DONE = 2'b11;
    // State transition logic (combinational)
    always@(*) begin
        case(state)
            Byte1 : begin
                if(in[3] == 1) begin
                    n_state = Byte2;
                end else begin
                    n_state = Byte1;
                end
            end

            Byte2 : begin
                n_state = Byte3;
            end

            Byte3 : begin
                n_state = DONE;   
            end

            DONE : begin
                if(in[3]==1) begin
                    n_state = Byte2;
                end else begin
                    n_state = Byte1;
                end
            end
        endcase
    end

    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset) begin
            state <= Byte1;
        end else begin
            state <= n_state;
        end
    end

    // Output logic
    assign done =(state==DONE );
endmodule

```

<br>

이번 문제에서 발생하는 경고 `Warning(21074)` 는 문제 구조상 `in[3]` 밖에 사용하지 않아 발생하는 오류로 크게 신경쓰지 않아도 됩니다.

<br>

## 3.2.5.16. PS / 2 packet parser and datapath (Fsm ps2data) 
### Module Declaration
난이도:  ★★★★☆

```verilog
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2

    // New: Datapath to store incoming bytes.

endmodule
```

<br>

이제 PS/2 바이트 스트림에서 3바이트 메시지를 식별하는 상태 머신이 생겼습니다.

패킷이 수신될 때마다 24비트(3바이트) 메시지를 출력하는 데이터 경로를 추가합니다.

(out_bytes[23:16]은 첫 번째 바이트, out_bytes[15:8]은 두 번째 바이트 등)

out_bytes는 완료 신호가 어서트될 때마다 유효한 것이어야 합니다.

그 외에는 아무 것도 출력할 수 있습니다(즉, 상관없습니다).

예시는 아래 이미지를 참고하세요.
<br>


```verilog
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //


reg [1:0] state, n_state;
parameter Byte1 = 2'b00, Byte2 = 2'b01, Byte3 = 2'b10, DONE = 2'b11;
reg [23:0] data, n_data;
    always@(*) begin
        n_data = data;
        n_state = state;
        case(state)
            Byte1 : begin
                if(in[3] == 1) begin
                    n_state = Byte2;
                    n_data[23:16] = in[7:0];
                end else begin
                    n_state = Byte1;
                    n_data = 0;
                end
            end

            Byte2 : begin
                n_state = Byte3;
                n_data[15:8] = in[7:0];
            end

            Byte3 : begin
                n_state = DONE; 
                n_data[7:0] = in[7:0];  
            end

            DONE : begin
                if(in[3]==1) begin
                    n_state = Byte2;
                    n_data = {in[7:0],16'b0};
                end else begin
                    n_state = Byte1;
                    n_data = 0;
                end
            end
        endcase
    end


    always@(posedge clk) begin
        if(reset) begin
            state <= Byte1;
            data <= 0;
        end else begin
            state <= n_state;
            data <= n_data;
        end
    end


    assign done =(state==DONE );
    assign out_bytes = (state == DONE) ? data : 24'bz;

endmodule
```

## 3.2.5.17. Serial Receiver (Fsm serial) 
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

endmodule
```

<br>

많은 (구형) 직렬 통신 프로토콜에서 각 데이터 바이트는 시작 비트와 정지 비트와 함께 전송되어 수신자가 비트 스트림에서 바이트를 구분할 수 있도록 합니다. 

일반적인 방식 중 하나는 시작 비트(0) 1개, 데이터 비트 8개, 정지 비트 1개(1)를 사용하는 것입니다.

또한 아무것도 전송되지 않을 때(유휴 상태) 회선은 논리 1에 있습니다.

비트 스트림이 주어졌을 때 바이트가 올바르게 수신된 시점을 식별하는 유한 상태 기계를 설계합니다.

시작 비트를 식별하고, 8개의 데이터 비트를 모두 기다린 다음, 정지 비트가 올바른지 확인해야 합니다.

예상한 시점에 정지 비트가 나타나지 않으면 FSM은 정지 비트를 찾을 때까지 기다렸다가 다음 바이트를 수신하려고 시도해야 합니다.

<br>


```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    reg [2:0] n_state, state;
    parameter IDLE =3'b000, DATA = 3'b001 , STOP = 3'b010 , DONE = 3'b011 , ERROR = 3'b100;
    

    always@(posedge clk) begin
        if(reset) begin
            state <= IDLE;
        end else begin
            state <= n_state;
        end
    end
    reg [3:0] cnt;
    always@(posedge clk) begin
        if(reset) begin
            cnt <= 0;
        end else if(state == DATA) begin
            cnt <= cnt + 1;
        end else begin
            cnt <= 0;
        end
    end

    always@(*) begin
       n_state = state;
        case(state)
            IDLE : begin
                if(in ==0) begin //start 1
                    n_state = DATA;
                end 
            end

            DATA : begin
                if(cnt == 7) begin
                    n_state = STOP;
                end else begin
                    n_state = DATA;
                end
            end
 
            STOP : begin
                if(in == 1) begin//stop
                    n_state = DONE;
                end else begin
                    n_state = ERROR;
                end      
            end  

            ERROR : begin
                if(in == 1) begin //start 1
                    n_state = IDLE;
                end else begin
                    n_state = ERROR;
                end
            end

            DONE : begin
                if(in == 0) begin 
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end

            
        endcase
    end

    assign done = (state == DONE );


endmodule
```

<br>

## 3.2.5.18. Serial receiver and datapath (Fsm serialdata)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial

    // New: Datapath to latch input bits.

endmodule
```

<br>
이제 직렬 비트스트림에서 바이트가 올바르게 수신된 시점을 식별할 수 있는 유한 상태 머신이 생겼습니다.

올바르게 수신된 데이터 바이트를 출력하는 데이터 경로를 추가합니다. 

out_byte는 done가 1일 때 유효해야 하며, 그렇지 않으면 상관없습니다.

직렬 프로토콜은 최하위 비트를 먼저 전송한다는 점에 유의하세요.
<br>



```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    reg [2:0] n_state, state;
    parameter IDLE =3'b000, DATA = 3'b001 , STOP = 3'b010 , DONE = 3'b011 , ERROR = 3'b100;
    reg [7:0] n_data, data;
 
    always@(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            data <= 0;
        end else begin
            state <= n_state;
            data <= n_data;
        end
    end
    reg [3:0] cnt;
    always@(posedge clk) begin
        if(reset) begin
            cnt <= 0;
        end else if(state == DATA) begin
            cnt <= cnt + 1;
        end else begin
            cnt <= 0;
        end
    end

    always@(*) begin
        n_data = data;
        if(state == DATA) begin
                n_data[cnt] = in;
        end 
    end

    always@(*) begin
       n_state = state;
        case(state)
            IDLE : begin
                if(in ==0) begin //start 1
                    n_state = DATA;
                end 
            end

            DATA : begin
                if(cnt == 7) begin
                    n_state = STOP;
                end else begin
                    n_state = DATA;
                end
            end
 
            STOP : begin
                if(in == 1) begin//stop
                    n_state = DONE;
                end else begin
                    n_state = ERROR;
                end      
            end  

            ERROR : begin
                if(in == 1) begin //start 1
                    n_state = IDLE;
                end else begin
                    n_state = ERROR;
                end
            end

            DONE : begin
                if(in == 0) begin 
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end

            
        endcase
    end

    assign done = (state == DONE );
    assign out_byte = data;


endmodule
```

## 3.2.5.19. Serial receiver with parity checking (Fsm serialdp)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Modify FSM and datapath from Fsm_serialdata

    // New: Add parity checking.

endmodule
```

<br>

직렬 수신기에 패리티 검사를 추가하려고 합니다. 

패리티 검사는 각 데이터 바이트 뒤에 비트를 하나 더 추가합니다.

수신되는 9 비트에서 1의 개수가 홀수여야하는 홀수 패리티를 사용합니다.

예를 들어 `101001011`은 홀수 패리티(1이 5개)를 만족하지만 `001001011`은 (1이 4개) 그렇지 않습니다.

홀수 패리티 검사를 수행하도록 FSM과 데이터 경로를 변경하세요.

입력 스트림의 패리티를 계산하는 데 사용할 수 있는 다음 모듈이 제공됩니다. (리셋 기능이 있는 TFF 입니다.)

```verilog
module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;
        // 10101010
        // 11001100

endmodule
```

이 모듈의 용도는 입력 비트 스트림이 주어지고 적절한 시점에 리셋되어 각 바이트의 1비트 수를 계산하는 것입니다.

<br>

```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Modify FSM and datapath from Fsm_serialdata

    reg [2:0] n_state, state;
    parameter IDLE =3'b000, DATA = 3'b001 , STOP = 3'b010;
    parameter DONE = 3'b011 , ERROR = 3'b100, PRT = 3'b101;
    reg [7:0] n_data, data;

    wire w_odd;
    reg r_reset;

    parity u_parity(clk, r_reset, in, w_odd);

    always@(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            data <= 0;
        end else begin
            state <= n_state;
            data <= n_data;
        end
    end

    reg [3:0] cnt;
    always@(posedge clk) begin
        if(reset) begin
            cnt <= 0;
        end else if(state == DATA) begin
            cnt <= cnt + 1;
        end else begin
            cnt <= 0;
        end
    end

    always@(*) begin
        n_data = data;
        if(state == DATA) begin
            n_data[cnt] = in;
        end 
    end

    always@(*) begin
        r_reset = reset;
        if(state == IDLE && in == 0) begin
            r_reset = 1;
        end
    end

    always@(*) begin
       n_state = state;
        case(state)
            IDLE : begin
                if(in ==0) begin //start 1
                    n_state = DATA;
                end 
            end

            DATA : begin
                if(cnt == 7) begin
                    n_state = PRT;
                end else begin
                    n_state = DATA;
                end
            end
    
            PRT : begin
                if((w_odd ==0 && in == 1) || (w_odd == 1 && in == 0)) begin
                    n_state = STOP;
                end else begin
                    n_state = ERROR;
                end
            end

            STOP : begin
                if(in == 1) begin//stop
                    n_state = DONE;
                end else begin
                    n_state = ERROR;
                end      
            end  

            ERROR : begin
                if(in == 1) begin //start 1
                    n_state = IDLE;
                end else begin
                    n_state = ERROR;
                end
            end

            DONE : begin
                if(in == 0) begin 
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end

            
        endcase
    end

    assign done = (state == DONE );
    assign out_byte = data;

endmodule
```

#### 동작 구상

1.  DATA -> PRT -> STOP 
    - 만약 n_data 를 XOR 시켰을 때 0 이면 1을 붙임 1이면 0을 붙임
    - 그렇지 않으면 ERROR 로 이동 

2. PRT 인스턴스화 동기화
    - `reset` 타이밍을 `state == IDLE` 이면서 `in ==0` 일 때 즉 다음 주기 때 `DATA` 로 들어갈 때 동작하게 설계

<br>


## 3.2.5.20. Sequence recognition (FSM hdlc)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset
    input in,
    output disc,
    output flag,
    output err);

endmodule
```

<br>

동기식 HDLC 프레이밍은 프레임(패킷)의 시작과 끝을 나타내는 비트 패턴을 찾기 위해 연속적인 데이터 비트 스트림을 디코딩하는 작업이 포함됩니다. 

정확히 6개의 연속된 1(예 : 01111110)이 보이는 것은 프레임 경계를 나타내는 `"플래그"` 입니다.

데이터 스트림에 실수로 `'플래그'`가 포함되는 것을 방지하기 위해 발신자는 연속 5개의 `1` 뒤에 0을 삽입하여 수신자가 이를 감지하고 삭제해야 합니다. 

또한 1이 7개 이상 연속되면 오류 신호를 보내야 합니다.

이 세 가지 시퀸스를 인식하는 유산 상태 머신을 설계합니다:

1. `0111110`: 비트를 버려야 한다는 신호(디스크). ( 1이 5개)

2. `01111110`: 프레임의 시작/끝에 플래그를 지정합니다(플래그). (1이 6개)

3. `01111111...`: 오류(7초 이상 1초 미만)(err).

FSM이 리셋되면 이전 입력이 0인 것처럼 동작하는 상태가 되어야 합니다

<br>

```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset
    input in,
    output disc,
    output flag,
    output err);

    reg [2:0] state , n_state;
    parameter IDLE = 3'b000, DATA = 3'b001, DISC = 3'b010, FLAG = 3'b011, ERROR = 3'b100;
    parameter DISC_DONE = 3'b101, FLAG_DONE = 3'b110 , ERROR_DONE = 3'b111;

    always@(posedge clk) begin
        if(reset) begin
            state <= IDLE;
        end else begin
            state <= n_state;
        end
    end
    
    reg [3:0] cnt; 



    always@(posedge clk) begin
        if(reset) begin
            cnt <= 0;
        end else if(state == DATA || state == DISC || state == FLAG || state == ERROR ) begin
            cnt <= cnt + 1;
        end else begin
            cnt <= 0;
        end
    end

    always@(*) begin
        n_state = state;
        case(state) 
        
            IDLE : begin
                if(in) begin
                    n_state = DATA; // in 1
                end
            end

            DATA : begin
                if(cnt == 3 && in) begin // in 4 cnt 3 && in 1 = in 이 5일 때 DISC 진입
                    n_state = DISC;
                end else if(in) begin // in 2 cnt 1 , in 3 cnt 2, in 4 cnt 3 
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end

            DISC : begin 
                if(in) begin 
                    n_state = FLAG; 
                end else begin
                    n_state = DISC_DONE;
                end
            end 

            FLAG : begin
                if(in) begin 
                    n_state = ERROR;  
                end else begin
                    n_state = FLAG_DONE;
                end
            end

            ERROR : begin
                if(in) begin
                    n_state = ERROR;
                end else begin
                    n_state = ERROR_DONE;
                end
            end     

            DISC_DONE : begin
                if(in) begin
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end

            FLAG_DONE : begin
                if(in) begin
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end

            ERROR_DONE : begin
                if(in) begin
                    n_state = DATA;
                end else begin
                    n_state = IDLE;
                end
            end           

        endcase
    end


assign disc = (state == DISC_DONE);
assign flag = (state == FLAG_DONE);
assign err = (state == ERROR); 
endmodule
```

<br>

이번 문제는 해결하는데 시간이 좀 걸렸습니다.

해결하는데 오류가 걸렸던 이유는 error 처리 과정과 카운팅 부분에서 문제가 있었습니다.

#### 카운팅 관련 문제 해결 방법

1. 카운팅을 처리하기 위해 `IDLE` 상태에서 `in = 1` 일때 `DATA`로 이동하였습니다.
    - `in = 1` , `cnt = 0`

2. 상태가 `DATA`일 때 카운팅이 시작됩니다. `in = 1` 이면 `n_state` 는 다음 동작을 진행합니다.
    - `in = 2`, `cnt = 1`
    - `in = 3`, `cnt = 2`
    - `in = 4`, `cnt = 3`

3. `in = 4`, `cnt =3` 일때  `if(cnt == 3 && in)` 중 `cnt == 3` 조건은 충족하고 `posedge clk` 에 `state` 가 변경되면 나머지 `&& in` 조건도 충족하기 때문에 `always@(*)` 블록에서 `in = 5` 인 상태이며 `posedge clk` 에 `state` 가 변경되면 `DISC` 상태로 이동이 됩니다.

#### `err` 관련 문제 해결 방법
1. 처음에 계속 `err` 신호가 출력이 안되서 다시 첨부된 이미지를 보았는데 `disc` ,`flag` 와 다르다는 것을 확인할 수 있었습니다.

2. `disc` 와 `flag` 는 `in` 이 0이 된 다음 주기에서 `1`이 되는 것을 확인할 수 있습니다.

3. 하지만 `err`같은 경우 특정 지점에서 시작하여 `0` 즉 오류가 끝날을 때 까지만 `1` 인 것을 확인할 수 있었습니다.

4. `err = (state == ERROR || state == ERROR_DONE)` 으로 선언을 하고 있어서 계속 에러가 발생하였고 종합적으로 에러가 발생하다 보니까 오류를 찾지 못했습니다.

<br>

## 3.2.5.21. Q8 : Design a Mealy FSM (Exams/ece241 2013 q8)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input aresetn,    // Asynchronous active-low reset
    input x,
    output z ); 

endmodule
```

<br>

`x`라는 입력 신호에서 `“101”` 시퀀스를 인식하는 밀리형 유한 상태 머신을 구현합니다. 

`“101”` 시퀀스가 감지되면 논리 `1`로 어설트되는 출력 신호 `z`가 FSM에 있어야 합니다. 

FSM에는 `active-low asynchronous reset`도 있어야 합니다. 상태 머신에는 3개의 상태만 있을 수 있습니다.

FSM은 `overlapping sequences`를 인식해야 합니다.

<br>

```verilog
module top_module (
    input clk,
    input aresetn,    // Asynchronous active-low reset
    input x,
    output z ); 

    reg r_z;

    reg [1:0] state ,n_state;
    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;

    always@(posedge clk, negedge aresetn) begin
        if(!aresetn) begin
            state <= S0;
        end else begin
            state <= n_state;
        end
    end

    always@(*) begin
    n_state = state;
        case(state)
            S0 : begin
                if(x) begin
                    n_state = S1;
                end else begin
                    n_state = S0;
                end
            end

            S1 : begin
                if(!x) begin
                    n_state = S2;
                end else begin
                    n_state = S1;
                end
            end

            S2 : begin
                if(x) begin
                    n_state = S1;
                end else begin
                    n_state = S0;
                end
            end

        endcase
    end

assign z = (state == S2 && x == 1);

endmodule
```

<br>

## 3.2.5.22. Q5a: Serial tow's complementer (Moore FSM) (Exams/ece241 2014 q5a)
### Module Declaration
난이도:  ★★★☆☆
```verilog
module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

endmodule
```

<br>

`one-input` `one-output` `serial 2's complementer` 무어 상태 머신를 설계해야 합니다. 

입력(x)은 숫자의 최하위 비트부터 시작하는 일련의 비트(클록 사이클당 하나)이고, 출력(Z)은 입력의 2의 보수입니다.

이 기계는 임의의 길이의 입력 숫자를 받아들입니다. 

이 회로에는 비동기 리셋이 필요합니다.

리셋이 해제되면 변환이 시작되고 리셋이 어설션되면 변환이 중지됩니다.

이미지를 참고해주세요.

<br>

#### 사전 지식
##### 2의 보수 계산법

2의 보수를 간단하게 계산해보겠습니다.

`MSB - - - - - - LSB` 로 동작할 때 `10010101` 이라는 숫자의 2의 보수는 `LSB`에 가까운 1을 고정시키고 나머지를 반전시키면 됩니다. `01101011` 

만약 `10010110` 이라면

답은 `01101010` 이 됩니다.


##### 어떻게 설계를 하면 될까?

무어 상태 머신에서는 출력이 오직 현재 상태에만 의존하기 때문에 입력값에 따라 출력이 달라져야 하는 경우, 각 입력에 대한 별도의 상태를 지정해야합니다.

첨부된 이미지를 보면 LSB -> MSB 로 이동되는 것을 확인할 수 있습니다.

이는 첫 `1`을 찾을 때 까지 출력을 0으로 만들어주면 됩니다.

만약에 첫 `1` 이 `input` 으로 들어오게 된다면 다음 상태부터 입력과 반대되는 출력을 보내주면 됩니다. 

따라서 정리하자면 다음과 같습니다 :


1. `1`이 처음 나오기 전에 입력이 `0`이라면 ? -> 출력 `0`

2. `1`이 처음 나오기 전에 입력이 `1`이라면 ? -> 출력 `1`

3. `1`이 처음 나온 후 입력이 `0`이라면 ? -> 출력 `1`

4. `1`이 처음 나온 후 입력이 `1`이라면? -> 출력 `0`

<br>

```verilog
module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

parameter DATA0 = 2'b00, DATA1 = 2'b01, CONV0 = 2'b10, CONV1 = 2'b11;
//
reg [1:0] state , n_state;


always@(posedge clk , posedge areset) begin
    if(areset) begin
        state <= DATA0;
    end else begin
        state <= n_state;
    end
end

always@(*) begin
    case(state) 
        DATA0 : begin
            if(x) begin
                n_state = DATA1;
            end else begin
                n_state = DATA0;
            end
        end

        DATA1 : begin
            if(x) begin
                n_state = CONV1;
            end else begin
                n_state = CONV0;
            end
        end

        CONV0 : begin
            if(x) begin
                n_state = CONV1;
            end else begin
                n_state = CONV0;
            end
        end

        CONV1 : begin
            if(x) begin
                n_state = CONV1;
            end else begin
                n_state = CONV0;
            end
        end


        default : n_state = DATA0;
    endcase
end

assign z = (state == DATA0) ? 1'b0 : 
           (state == DATA1) ? 1'b1 : 
           (state == CONV0) ? 1'b1 :
           (state == CONV1) ? 1'b0 : 1'b0;

endmodule
```

<br>

## 3.2.5.23. Q5b: Serial two's complementer (Mealy FSM) (Exmas/ece241 2014 q5b)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

endmodule
```

<br>

이번 문제에서 다음 다이어그램은 2의 보수를 구현한 밀리 상태 머신입니다.

원핫 인코딩을 사용하여 구현합니다.

<br>

```verilog
module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    reg  [1:0] state , n_state;
    parameter A = 0 , B = 1; // 원핫 인코딩 비트 위치를 의미

    always@(posedge clk, posedge areset) begin
        if(areset) begin
            state <= 2'b01;
        end else begin
            state <= n_state;
        end
    end
    
    assign n_state[A] =  (state[A] & ~x) || (areset);
    assign n_state[B] = (state[A] & x ) || (state[B]);

    assign z = (state[A] & x ) || (state[B] && ~x);
endmodule
```

<br>

## 3.2.5.24. Q3a: FSM (Exmas/2014 q3fsm)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

endmodule
```

<br>

입력 s와 w가 있는 유한 상태 머신을 생각해 보겠습니다. 

아래 그림과 같이 FSM이 A라는 리셋 상태에서 시작한다고 가정합니다. 

FSM은 s = 0인 한 상태 A를 유지하고, s = 1이 되면 상태 B로 이동합니다.

B 상태가 되면 FSM은 다음 세 클록 주기 동안 입력 w의 값을 검사합니다.

이 클록 주기 중 정확히 두 클록 주기에서 w가 1이면 FSM은 다음 클록 주기에서 출력 z를 1로 설정해야 합니다.

그렇지 않으면 z는 0이어야 합니다.

FSM은 다음 세 클록 주기 동안 계속해서 w를 확인합니다.

아래 타이밍 다이어그램은 다양한 w 값에 필요한 z 값을 보여줍니다.

가능한 한 적은 상태를 사용합니다. s 입력은 상태 A에서만 사용되므로 w 입력만 고려해야 합니다.

<br>

```verilog
module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

reg [1:0] state , n_state; 
reg r_z, r_z_d;
reg [2:0] cnt;
parameter A = 2'b00 , B0 = 2'b01, B1 = 2'b10 , B2 = 2'b11;

    always@(posedge clk) begin
        if(reset) begin
            state <= A;
        end else begin
            state <= n_state;
        end
    end 



    always@(*) begin
    n_state = state;
        case(state)
            A : begin
                if(s) begin
                    n_state = B0;
                end 
            end

            B0 : begin 
                    n_state = B1;
                    cnt[2] = w;
            end

            B1 : begin
                    n_state = B2;
                    cnt[1] = w;
            end 

            B2 : begin
                    n_state = B0;   
                    cnt[0] = w;
            end

            default : cnt = 0;




        endcase
    end

    always@(*) begin
        if(state == B2) begin
            r_z = (cnt == 3'b110 || cnt == 3'b101 || cnt == 3'b011) ? 1 : 0;
        end else begin
            r_z = 0;
        end
    end

    always@(posedge clk) begin
        if(reset) begin
            r_z_d <= 0;
        end else begin
        r_z_d <= r_z;
        end
    end

    assign z = r_z_d;

endmodule
```

<br>

또는 이렇게도 해결이 가능합니다.

<br>

```verilog
module top_module(
    input clk,
    input reset,
    input s,
    input w,
    output z
);

    reg [1:0] state, n_state;
    reg [1:0] cnt;
    reg r_z;

    parameter A = 2'b00, B0 = 2'b01, B1 =2'b10, B2 = 2'b11;

    always@(posedge clk) begin
        if(reset) begin
            state <= A;
        end else begin
            state <= n_state;
        end
    end

    always@(posedge clk) begin
        if(reset) begin
            cnt <= 3'b000;
            r_z <= 1'b0;
        end else begin
            case(state)
                B0: begin
                    cnt[1] <= w;
                end
                
                B1: begin
                    cnt[0] <= w;
                end
                
                B2 : begin
                    r_z <= ((cnt[2] + cnt[1] + w) == 2'd2) ? 1'b1 : 1'b0;
                end

                default : begin
                    if(state == A) begin
                        cnt <= 3'b000;
                    end
                end
            endcase

            if(n_state != B0 || state == A) begin
                r_z <= 1'b0;
            end
        end
    end


    always@(*) begin
        n_state = state;
        case(state) 
            A : begin
                if(s) begin
                    n_state = B0;
                end
            end

            B0 : begin
                n_state = B1;
            end

            B1 : begin
                n_state = B2;
            end

            B2 : begin
                n_state = B0;
            end

            default : n_state = A;

        endcase
    end


    assign z = r_z;

endmodule
```

<br>

## 3.2.5.25. Q3b: FSM (Exams/2014 q3bfsm)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

endmodule
```

<br>

아래에 표시된 상태 할당 표가 주어지면 유한 상태 머신을 구현합니다.

재설정은 FSM을 상태 000으로 초기화해야 합니다.

<br>

```verilog
module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

reg [2:0] state , n_state;
reg r_z;

    always@(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
        end else begin
            state <= n_state;
        end
    end

    always@(*) begin
        case(state) 
            3'b000 : begin
                if(x) begin
                    n_state = 3'b001;
                end else begin
                    n_state = 3'b000;
                end
            end

            3'b001 : begin
                if(x) begin
                    n_state = 3'b100;
                end else begin
                    n_state = 3'b001;
                end
            end

            3'b010 : begin
                if(x) begin
                    n_state = 3'b001;
                end else begin
                    n_state = 3'b010;
                end
            end
            3'b011 : begin
                if(x) begin
                    n_state = 3'b010;
                end else begin
                    n_state = 3'b001;
                end
            end
            3'b100 : begin
                if(x) begin
                    n_state = 3'b100;
                end else begin
                    n_state = 3'b011;
                end
            end
        endcase
    end

    always@(*) begin
        case(state) 
        
        3'b000 : r_z = 0;
        3'b001 : r_z = 0;
        3'b010 : r_z = 0;
        3'b011 : r_z = 1;
        3'b100 : r_z = 1;
        endcase
    end

    assign r = r_z;

endmodule
```

<br>

## 3.2.5.26. Q3c: FSM logic (Exams/2014 q3c)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

endmodule
```

<br>

아래에 표시된 상태 할당 테이블이 주어지면 논리 함수 Y[0]과 z를 구현합니다.

<br>


```verilog
module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

reg [2:0] n_state;
reg r_z;
reg r_y;

always@(posedge clk) begin
    n_state <= y;
end

always@(*) begin
    case(y)
        3'b000 : begin
            if(x) begin
                n_state = 3'b001;
            end else begin
                n_state = 3'b000;
            end
        end

        3'b001 : begin
            if(x) begin
                n_state = 3'b100;
            end else begin
                n_state = 3'b001;
            end
        end

        3'b010 : begin
            if(x) begin
                n_state = 3'b001;
            end else begin
                n_state =  3'b010;
            end
        end

        3'b011 : begin
            if(x) begin
                n_state = 3'b010;
            end else begin
                n_state = 3'b001;
            end
        end

        3'b100 : begin
            if(x) begin
                n_state = 3'b100;
            end else begin
                n_state = 3'b011;
            end
        end
      
        default : begin
            n_state = 3'b000;
        end
    endcase
end


always@(*) begin
    r_z = 1'b0;
    case(y)
        3'b000 : r_z = 0;
        3'b001 : r_z = 0;
        3'b010 : r_z = 0;
        3'b011 : r_z = 1;
        3'b100 : r_z = 1;
        default : r_z = 0;
    endcase
end

always(*) begin
    r_y = 1'b0;
    case(y)
        3'b000 : r_y = x ? 1'b1 : 1'b0;
        3'b001 : r_y = x ? 1'b0 : 1'b1;
        3'b010 : r_y = x ? 1'b1 : 1'b0;
        3'b011 : r_y = x ? 1'b0 : 1'b1;
        3'b100 : r_y = x ? 1'b0 : 1'b1;
        default : r_y = 1'b0;
    endcase
end


assign z = r_z;
assign Y0 = r_y;

endmodule
```

<br>

단순 로직으로만 문제를 해결하려면 다음과 같이 해결할 수 있습니다.

<br>

```verilog
module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);


    assign Y0 = (y == 3'b000 && x == 1) ||
                (y == 3'b001 && x == 0) ||
                (y == 3'b010 && x == 1) ||
                (y == 3'b011 && x == 0) ||
                (y == 3'b100 && x == 0);

    aasign z = (y == 3'b011 || y == 3'b100);

endmodule
```


## 3.2.5.27. Q6b : FSM next - state logic (Exams/m2014 q6b)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input [3:1] y,
    input w,
    output Y2);

endmodule
```

<br>

입력 `w` 와 출력 `z` 가 하나씩 있는 아래 이미지를 참고하여 상태 머신을 생각해 봅시다.

3개의 플립플롭과 상태 코드 `y[3:1] = 000,001,...,101`을 각각 상태 `A,B,...,F`에 사용하여 FSM을 구현하고자 한다고 가정합니다.

y[2]에 대한 다음 상태 식을 도출합니다.

y[2]에 대한 다음 상태 논리만 구현합니다.

<br>

일단 다음 상태를 표로 제작하면 다음과 같습니다.
| state   | bit | input `w` | n_state | bit | output `z` |
|:--------:|:--------:|:-----:|:--------:|:------------:|:-----:|
| A        | 000      |   0   | B        | 001          |   0   |
| A        | 000      |   1   | A        | 000          |   0   |
| B        | 001      |   0   | `C`      | 010          |   0   |
| B        | 001      |   1   | `D`      | 011          |   0   |
| C        | 010      |   0   | E        | 100          |   0   |
| C        | 010      |   1   | `D`      | 011          |   0   |
| D        | 011      |   0   | F        | 101          |   0   |
| D        | 011      |   1   | A        | 000          |   0   |
| E        | 100      |   0   | E        | 100          |   1   |
| E        | 100      |   1   | `D`      | 011          |   0   |
| F        | 101      |   0   | `C`      | 010          |   1   |
| F        | 101      |   1   | `D`      | 011          |   1   |


y[2]는 n_state 의 2번쨰 비트이며 이것이 1이 되는 상황은 다음과 같습니다.

1. 현재 상태가 `B` 이고 `W = 0` 일 때, 다음 상태는 `C`
2. 현재 상태가 `B` 이고 `W = 1` 일 때, 다음 상태는 `D`
3. 현재 상태가 `C` 이고 `W = 1` 일 때, 다음 상태는 `D`
4. 현재 상태가 `E` 이고 `W = 1` 일 때, 다음 상태는 `D`
5. 현재 상태가 `F` 이고 `W = 0` 일 때, 다음 상태는 `C`
6. 현재 상태가 `F` 이고 `W = 1` 일 때, 다음 상태는 `D`

즉 Y2 가 1이려면 다음 조건을 만족해야 합나디.

1. 현재 상태가 `B = 3'b001`
2. 현재 상태가 `C = 3'b010` 이고 `W = 1` 
3. 현재 상태가 `E = 3'b100` 이고 `W = 1`
4. 현재 상태가 `F = 3'b101` 


이를 논리식으로 표현하면 다음과 같습니다.


```verilog
Y2 = (!y[3] & !y[2] & y[1]) | 
     (!y[3] & y[2] & !y[1] & w) | 
     (y[3] & !y[2] & !y[1] & w) | 
     (y[3] & !y[2] & y[1]);

```

<br>

따라서 결과는 다음과 같습니다.

```verilog
module top_module (
    input [3:1] y,
    input w,
    output Y2);

assign Y2 = (!y[3] & !y[2] & y[1]) | 
     (!y[3] & y[2] & !y[1] & w) | 
     (y[3] & !y[2] & !y[1] & w) | 
     (y[3] & !y[2] & y[1]);


endmodule
```

<br>

## 3.2.5.28. Q6c : FSM one-hot next-state logic (Exmas/m2014 q6c)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input [6:1] y,
    input w,
    output Y2,
    output Y4);

endmodule

```

<br>

이미지의 상태 머신은 하나의 입력 `w` 와 하나의 출력 `z`를 가지고 있습니다.

이 부분에서는 상태 할당 `y[6:1] = 000001, 000010, 000100, ... ` 이 각각 상태 A ~ F 의 대해 원핫 코드가 사용된다고 가정합니다.

다음 상태 신호 Y2, Y4 에 대한 논리 식을 작성합니다.

원핫 인코딩을 가정하여 검사하여 논리 방정식을 도출합니다.

다음 이미지를 표로 작성하면 다음과 같습니다.

| state   | bit | input `w` | n_state | bit 
|:--------:|:--------:|:-----:|:--------:|:------------:|
| A        | 000001      |   0   | `B`      | 000010          |
| A        | 000001      |   1   |  A       | 000001          | 
| B        | 000010      |   0   |   C      | 000100          | 
| B        | 000010      |   1   | `D`      | 001000          | 
| C        | 000100      |   0   | E        | 010000          | 
| C        | 000100      |   1   |   `D`    | 001000          |  
| D        | 001000      |   0   | F        | 100000          |   
| D        | 001000      |   1   | A        | 000001          |  
| E        | 010000      |   0   | E        | 010000          |  
| E        | 010000      |   1   |   `D`      | 000100        |  
| F        | 100000      |   0   |   C      | 000100          |  
| F        | 100000      |   1   |   `D`    | 001000          |   

<br>

Y2, Y4가 1이 되는 상황은 다음과 같습니다.

1. 현재 상태가 `A` 이고 `W = 0` 일 때, 다음 상태는 `B`
2. 현재 상태가 `B` 이고 `W = 1` 일 때, 다음 상태는 `D`
3. 현재 상태가 `C` 이고 `W = 1` 일 때, 다음 상태는 `D`
4. 현재 상태가 `E` 이고 `W = 1` 일 때, 다음 상태는 `D`
5. 현재 상태가 `F` 이고 `W = 1` 일 때, 다음 상태는 `D`

이를 논리식으로 표현하면 다음과 같다.

```verilog
Y2 = (y[1] & !w);

Y4 = (y[2] & w) |
     (y[3] & w) |
     (y[5] & w) |
     (y[6] & w) ;
```

<br>

따라서 결과는 다음과 같습니다.

<br>


```verilog
module top_module (
    input [6:1] y,
    input w,
    output Y2,
    output Y4);

assign Y2 = (y[1] & !w);

assign Y4 = (y[2] & w) |
            (y[3] & w) |
            (y[5] & w) |
            (y[6] & w) ;


endmodule
```


## 3.2.5.29. Q6 : FSM (Exams/m2014 q6)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input reset,     // synchronous reset
    input w,
    output z);

endmodule
```

<br>

이미지를 참고하면 상태 머신은 하나의 입력 `w` 와`z` 를 가지고 있습니다.

상태 머신을 구현합니다.

<br>



```verilog
module top_module (
    input clk,
    input reset,     // synchronous reset
    input w,
    output z);


reg [2:0] state, n_state;
parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100 ,F = 3'b101;

always@(posedge clk) begin
    if(reset) begin
        state <= A;
    end else begin
        state <= n_state;
    end
end

always@(*) begin
    case(state)
        A : begin
            if(w) begin
                n_state = A;
            end else begin
                n_state = B;
            end
        end

        B :begin
            if(w) begin
                n_state = D;
            end else begin
                n_state = C;
            end
        end

        C : begin
            if(w) begin
                n_state = D;
            end else begin
                n_state = E;
            end
        end

        D : begin
            if(w) begin
                n_state = A;
            end else begin
                n_state = F;
            end
        end

        E : begin
            if(w) begin
                n_state = D;
            end else begin
                n_state = E;
            end
        end

        F : begin
            if(w) begin
                n_state = D;
            end else begin
                n_state = C;
            end
        end

    endcase
end


assign z = (state == F || state == E);

endmodule
```

## 3.2.5.30. Q2a : FSM (Exams/2012 q2fsm)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    input w,
    output z
);

endmodule
```


<br>

이미지를 참고합니다.

이 FSM을 나타내는 완전한 Verilog 코드를 작성합니다.

강의에서 배운 대로 상태 테이블과 상태 플립플롭에 별도의 `always block`을 사용합니다.

`continuous assignment ` 또는 `always block `을 사용하여 `z`를 출력합니다.



<br>

```verilog
module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    input w,
    output z
);


reg [2:0] state, n_state;
parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100 ,F = 3'b101;

always@(posedge clk) begin
    if(reset) begin
        state <= A;
    end else begin
        state <= n_state;
    end
end

always@(*) begin
    case(state)
        A : begin
            if(w) begin
                n_state = B;
            end else begin
                n_state = A;
            end
        end

        B :begin
            if(w) begin
                n_state = C;
            end else begin
                n_state = D;
            end
        end

        C : begin
            if(w) begin
                n_state = E;
            end else begin
                n_state = D;
            end
        end

        D : begin
            if(w) begin
                n_state = F;
            end else begin
                n_state = A;
            end
        end

        E : begin
            if(w) begin
                n_state = E;
            end else begin
                n_state = D;
            end
        end

        F : begin
            if(w) begin
                n_state = C;
            end else begin
                n_state = D;
            end
        end

    endcase
end


assign z = (state == F || state == E);

endmodule
```

## 3.2.5.31. Q2b : one-hot FSM equations
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input [5:0] y,
    input w,
    output Y1,
    output Y3
);

endmodule
```

<br>

상대 할당 y[5::0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E),100000(F) 

상태 플립플롭 `y[1]`, `y[3]`의 입력인 신호 `Y1`,`Y3`에 대한 논리식을 작성합니다.

(원핫 인코딩을 가정하여 검사를 통해 논리 방정식을 도출합니다.)

(테스트벤치는 더 복잡한 작업을 시도하지 않는지 확인하기 위해 원핫이 아닌 입력으로 테스트합니다.)

<br>


| state   | bit | input `w` | n_state | bit 
|:--------:|:--------:|:-----:|:--------:|:------------:|
| A        | 000001      |   0   | A      | 000001          |
| A        | 000001      |   1   |  `B`       | 000010          | 
| B        | 000010      |   0   |   `D`      | 001000          | 
| B        | 000010      |   1   | C      | 000100          | 
| C        | 000100      |   0   | `D`        | 001000          | 
| C        | 000100      |   1   |   E    | 010000          |  
| D        | 001000      |   0   | A        | 000001         |   
| D        | 001000      |   1   | F        | 100000          |  
| E        | 010000      |   0   | `D`        | 000100          |  
| E        | 010000      |   1   |   E      | 010000        |  
| F        | 100000      |   0   |   `D`      | 001000          |  
| F        | 100000      |   1   |   C    | 000100          |  

<br>


```verilog
module top_module (
    input [5:0] y,
    input w,
    output Y1,
    output Y3
);


assign Y1 = y[0] & w;

assign Y3 = (y[1] & !w) | (y[2]) & !w | (y[4] & !w) | (y[5] & !w);


endmodule

```

<br>


## 3.2.5.32. Q2a : FSM (Exams/2013 q2afsm)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input [3:1] r,   // request
    output [3:1] g   // grant
); 

endmodule
```


<br>

이 FSM은 세 개의 요청 장치에서 특정 유형의 리소스에 대한 액세스를 제어하는 중재자 회로 역할을 합니다.

각 장치는 신호 `r[i] =1`을 설정하여 리소스를 요청하는데, 여기서 `r[i]`은 `r[1]`, `r[2]` 또는 `r[3]` 중 하나입니다.

각 `r[i]`는 FSM에 대한 입력 신호이며, 세 개의 장치중 하나를 나타냅니다.

FSM은 요청이 없는 한 상태 A를 유지합니다.

하나 이상의 요청이 발생하면 FSM은 리소스 사용 허가를 받을 장치를 결정하고 해당 장치의 `g[i]` 신호를 `1`로 설정하는 상태로 변경합니다.

각 `g[i]`는 FSM의 출력입니다.

우선순위 시스템이 있어 장치1은 장치 2보다 우선순위가 높고, 장치 3은 우선 순위가 가장 낮습니다.

따라서 예를 들어, 장치 3은 FSM이 상태 A일 때 요청하는 유일한 장치인 경우에만 허가를 받습니다.

장치 i가 FSM으로 부터 허가를 받으면 해당 장치는 요청이 `r[i] = 1`인 한 계속 허가를 받습니다.

이 FSM을 나타내는 완전한 Verilog 코드를 작성합니다. 

이 문제를 정리하면 다음과 같습니다.

1. 세 개의 장치가 각각 리소스를 요청할 수 있습니다.

2. 각 장치는 `r[i]` 신호를 `1`로 설정하여 요청합니다.

3. FSM은 우선순위 규칙에 따라 어떤 장치에 자원 사용 권한을 줄지 결정합니다.

4. 선택된 장치에 대해 해당 `g[i]` 출력 신호를 `1`로 설정합니다.

우선순위 규칙은 다음과 같습니다.

1. 장치1 > 장치2 > 장치3 의 순서로 우선순위를 갖습니다.
   - 예시: 장치3은 다른 장치의 요청이 없을 때만 권한을 받을 수 있습니다.

2. 한 장치가 권한을 받으면, 해당 장치의 요청 `r[i]`이 `1`인 동안 계속 권한을 유지합니다.

<br>


```verilog

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input [3:1] r,   // request
    output [3:1] g   // grant
); 

reg [1:0] state, n_state;
parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;


always@(posedge clk) begin
    if(!resetn) begin
        state <= A;
    end else begin
        state <= n_state;
    end
end


always@(*) begin
    case(state)
        A : begin
            if(r[1]) begin
                n_state = B;
            end else if(!r[1] & r[2]) begin
                n_state = C;
            end else if (!r[1] & !r[2] & r[3]) begin
                n_state = D;
            end else begin
                n_state = A;
            end
        end
        
        B : begin
            if(r[1]) begin
                n_state = B;
            end else begin
                n_state = A;
            end
        end

        C : begin
            if(r[2]) begin
                n_state = C;
            end else begin 
                n_state = A;
            end
        end

        D : begin
            if(r[3]) begin
                n_state = D;
            end else begin 
                n_state = A;
            end
        end
    endcase
end

assign g = {state == D, state == C, state == B};

endmodule
```

<br>

## 3.2.5.33. Q2b: Another FSM (Exams/2013 q2bfsm)
### Module Declaration
난이도:  ★★★★☆
```verilog
module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
); 

endmodule
```

<br>

어떤 유형의 모터를 제어하는 데 사용되는 유한 상태 머신을 생각해 봅시다.

FSM에서는 모터에서 오는 입력 x,y가 있고 모터를 제어하는 출력 f,g를 생성합니다.

또한 clk 입력과 resetn 이 있습니다.

FSM은 다음과 같이 작동해야 합니다.

리셋 입력이 어설트되는 동안 FSM은 시작 상태(상태 A)를 유지합니다.

리셋 신호가 해제되면 다음 클록 에지 이후에 FSM은 한 클록 주기 동안 출력 f를 1로 설정해야 합니다.

그런 다음 FSM은 x 입력을 모니터링해야 합니다.

x가 세 번의 연속 클록 사이클에서 1, 0, 1 값을 생성하면 다음 클록 사이클에서 g를 1로 설정해야 합니다. 

g = 1을 유지하는 동안 FSM은 y 입력을 모니터링해야 합니다. 

최대 두 클록 주기 내에 y 값이 1이면 FSM은 g = 1을 영구적으로(즉, 리셋될 때까지) 유지해야 합니다. 

그러나 두 클록 주기 내에 y가 1이 되지 않으면 FSM은 g = 0을 영구적으로(리셋할 때까지) 설정해야 합니다.


**요약하면 다음과 같습니다.**

1. 리셋 입력이 활성화 되있는 동안 초기 상태를 유지합니다.

2. 리셋이 해제되면 출력 `f`를 `1클럭`동안 `1`로 설정합니다.

3. 그 후 FSM은 입력 `x` 를 모니터링 합니다.
    - `x`가 연속 3 사이클 동안 `1,0,1` 순서로 값을 가지면, 다음 클럭 사이클에서 출력 `g`를 1로 설정합니다.

4. `g = 1`인 상태에서 FSM은 입력`y`를 모니터링 합니다.
   - 최대 2 사이클 내에 `y = 1`이 되면, FSM은 `g = 1`을 영구적으로 유지합니다. (리셋되기 전까지)
   - 그러나 두 클럭 사이클 내에 `y = 1`가 되지 않으면, FSM 은 `g = 0`으로 설정하고 영구적으로 유지합니다.(리셋되기 전까지)

<br>

```verilog
module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
); 
reg [3:0] state, n_state;
parameter IDLE = 4'b0000, MNTx0 = 4'b0001, MNTx1 = 4'b0010, MNTx2 = 4'b0011, MNTy0 = 4'b0100, MNTy1 = 4'b0101, F = 4'b0110, MNTy = 4'b0111, MNTyn = 4'b1000;

always@(posedge clk) begin
    if(!resetn) begin
        state <= IDLE;
    end else begin
        state <= n_state;
    end
end
/*
reg r_d0, r_d1;
always@(posedge clk) begin
    if(!resetn) begin
        r_d0 <= 0;
        r_d1 <= 0;
    end else begin
        r_d0 <= 1;
        r_d1 <= r_d0;
    end
end

assign f = r_d0 & !r_d1;
*/

always@(*) begin
    n_state = state;
    case(state)
        IDLE : begin
            n_state = F;
        end

        F : begin
            n_state = MNTx0;
        end
        MNTx0 : begin
            if(x) begin
                n_state = MNTx1;
            end else begin
                n_state = MNTx0;
            end
        end

        MNTx1 : begin 
            if(!x) begin
                n_state = MNTx2;
            end else begin
                n_state = MNTx1;
            end
        end
    
        MNTx2 : begin
            if(x) begin
                n_state = MNTy0;
            end else begin 
                n_state = MNTx0;
            end
        end

        MNTy0 : begin
            if(y) begin
                n_state = MNTy;
            end else begin
                n_state = MNTy1;
            end
        end

        MNTy1 : begin
            if(y) begin
                n_state = MNTy;
            end else begin 
                n_state = MNTyn;
            end
        end

    
        MNTy : begin
                n_state = MNTy;
        end

        MNTyn : begin
                n_state = MNTyn;
        end

    
    endcase
end

assign f = (state == F);
assign g = (state == MNTy0 | state == MNTy1 | state == MNTy);


endmodule
```

#### 문제 해결 사항
1. 처음에는 주석 처리된 부분을 사용하여 `1클럭` 동안 `F`를 유지하는 데 사용했지만 단순하게 `state` 를 한 개 더 추가해서 푸는 문제였습니다.

2. `1,0,1` `state`를 설정할 때 처음에는 두번째 상태에서 0이 아닐 때 첫번 째 상태로 돌아가게 설계했습니다. 
   - 하지만 그러게 설계를 하게 된다면 2번째 상태가 1일 때 다시 첫번째 상태에서도 1일 때 동작하기 때문에 101 이 정확히 입력되지 않고 1101 이 되는 상태가 발생했습니다.
   - 따라서 2번째 상태에서 `else` 부분을 재자리로 가게 설정하여 1이 입력된 상태를 유지했습니다.
  
   - before 
        ```verilog
            MNTx1 : begin 
                if(!x) begin
                    n_state = MNTx2;
                end else begin
                    n_state = MNTx0;
                end
            end
        ```
    
    - after
        ```verilog
            MNTx1 : begin 
                if(!x) begin
                    n_state = MNTx2;
                end else begin
                    n_state = MNTx1;
                end
            end
        ```

#### 다음에 계속

---

