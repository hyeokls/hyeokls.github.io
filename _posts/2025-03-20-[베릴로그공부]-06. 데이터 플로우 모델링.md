---
title: "[베릴로그 HDL] 06. 데이터 플로우 모델링"
date: 2025-03-20 00:58:00 +09:00
categories: [Verilog, 베릴로그공부]
tags:
  [
    verilog,
    systemverilog,
    Vivado,
    Vitis
  ]
---

# 6. 데이터 플로우 모델링
## 목표
1. 연속 할당 구문인 assign 문에 대해 알아보기

2. 연산자, 피연산자 그리고 문장에 대한 선언에 대해 알아보기.

3. 모든 가능한 연산에 대한 연산자 형을 알아보기.

4. 데이터플로우 모델링 기법을 이용한 실질적인 디지털 회로 설계를 공부하기

## 6.1 연속할당
✅ Verilog에서 연속 할당(Continuous Assignment)이란?

연속 할당은 Verilog의 **데이터 플로우 모델링**에서 가장 기본적인 문장으로, `넷(net) 타입 변수`에 값을 지속적으로 할당하는 데 사용됩니다.

이는 `조합 논리 회로`를 모델링하는 데 매우 유용하며, 우변의 값이 변화할 때마다 좌변에 즉시 반영됩니다.

#### 📌 연속 할당의 특징
1. assign 키워드 사용

    - 연속 할당은 assign 키워드를 통해 값을 넷 타입 변수에 할당합니다.

2. 우변 변화 감지
    - 우변의 값이 변경되면 좌변의 넷 변수에 즉시 반영됩니다.

3. net 타입
    - 연속 할당은 주로 `wire` 타입의 변수와 함께 사용됩니다.

4. 지연값 및 신호 강도 지원

    - 지연값을 설정하여 값이 할당되는 시간을 제어할 수 있으며, 신호 강도를 지정할 수 있습니다.

#### 📌 연속 할당 문법

```verilog
assign [신호 강도] [지연값] net_assignment;
```

- `신호 강도`: 신호의 드라이브 강도를 설정합니다. (예: strong0, weak1)

- `지연값`: 값이 넷에 할당될 때 걸리는 시간을 설정합니다.

- `net_assignment`: 넷(wire) 변수에 값을 할당하는 표현식.

#### 📌 연속 할당 사용 예제

예제 1: 기본 연속 할당

```verilog
module BasicAssignExample(input a, input b, output wire out);
    wire out;

    assign out = a & b; // AND 연산 결과를 out에 연속적으로 할당
endmodule
```

✔ 설명:

- 입력 신호 a, b의 AND 결과가 출력 신호 out에 지속적으로 반영됩니다.

예제 2: 다중 연속 할당

```verilog
module MultiAssignExample;
    wire [7:0] out1, out2;

    assign (strong0, weak1) #5 out1 = a & b, out2 = c & d; // 다중 연속 할당
endmodule
```

✔ 설명:

- 두 개의 출력 벡터(out1, out2)를 동시에 설정하며, 신호 강도와 지연값을 지정했습니다.

- 출력은 각각 5 단위 시간 후에 반영됩니다.

#### 📌 지연값과 신호 강도 활용

예제 3: 지연값과 신호 강도 설정

```verilog
module DelayAndStrengthExample;
    wire out;

    assign (strong0, weak1) #10 out = a | b; // OR 연산 결과를 10 단위 시간 후에 반영
endmodule
```

✔ 설명:

- 출력 신호 out은 입력 신호 a, b의 OR 결과를 계산한 후, 10 단위 시간 후에 반영됩니다.

- 신호 강도를 설정하여 출력 신호의 드라이브 특성을 정의했습니다.

- 입력 변화가 10 단위 미만일 경우 출력 반영이 되지 않습니다.


#### 주의점
1. 연속 할당문의 왼쪽은 항상 스칼라나 벡터의 넷, 또는 스칼라넷과 벡터 넷으로 합쳐진 것이여야 한다. 
    - 왼쪽에는 스칼라나 벡터의 레지스터형은 올 수 없다.

2. 연속 할당문은 항상 능동적이다.
    - 할당문은 항상 오른쪽 피연산자들이 값이 바뀌자마자 왼쪽의 넷에 값을 할당한다.

3. 연산자의 오른쪽에 올 수 있는 것은 레지스터, 넷, 함수 호출문이다.
    - 레지스터 또는 넷은 스칼라나 벡터가 될 수 있다.

4. 지연값은 할당문 안에서 단위 시간으로 지정된다.
    - 지연 값은 넷에 값을 할당할 때 걸리는 시간을 제어하기 위해 사용된다.


### 6.1.1 함축적 연속 할당문
✅ Verilog에서 함축적 연속 할당문과 함축적 넷 선언

Verilog의 함축적 연속 할당문과 함축적 넷 선언은 코드를 간결하게 작성하는 데 도움을 줍니다.

함축적 연속 할당문은 넷 선언과 연속 할당을 한 줄로 표현하며, 함축적 넷 선언은 여러 넷을 한 번에 선언할 수 있는 방법입니다.

#### 📌 1. 함축적 연속 할당문

**구문**
```verilog
wire [width:0] net_name = expression;
```

**예제**

```verilog
wire [7:0] out = a & b; // out에 a와 b의 논리곱을 할당
```

**기존 방식과의 비교**

```verilog
wire [7:0] out;
assign out = a & b;

```

✔ 설명:

- out 넷에 a와 b의 논리곱 결과를 연속적으로 할당합니다.

- 기존의 assign 문과 동일한 기능을 제공하지만 코드가 더 간결합니다.


#### 📌 2. 함축적 넷 선언

**예제**
```verilog
wire i1, i2;
assign out = i1 & i2;
```

✔ 설명:

- 연속 할당문의 좌변에 사용된 신호가 미리 선언되지 않았지만 자동으로 적용됩니다.

- `default_nettype none` 지시어를 사용하면 함축적 넷 선언이 비활성화 됩니다.
**함축적 넷 선언의 장점**

- 코드가 간결해져 가독성이 향상됩니다.

- 여러 넷을 한 번에 선언할 수 있어 효율적입니다.

**예제: 함축적 연속 할당문과 함축적 넷 선언 사용**

```verilog
module ExampleModule;
    wire i1, i2;
    wire [7:0] out = i1 & i2; // 함축적 연속 할당문 사용

    initial begin
        $monitor("i1 = %b, i2 = %b -> out = %b", i1, i2, out);
    end
endmodule
```

✔ 설명:

- 함축적 연속 할당문을 사용하여 out 넷에 i1과 i2의 논리곱 결과를 할당합니다.



## 6.2 지연

### 6.2.1. 정규 할당 지연
✅ Verilog에서 정규 할당 지연(Regular Delay Assignment)이란?

Verilog의 **정규 할당 지연(Regular Delay Assignment)**은 연속 할당문에 직접 지연값을 할당하여 신호가 전파되거나 처리되는 시간을 모델링하는 방법입니다. 

이는 **관성 지연(Inertial Delay)**과 유사하며, 입력 신호의 유지 시간이 지연 시간보다 짧으면 출력에 영향을 미치지 않을 수 있습니다.

```verilog
assgin #10 out = a & b; // 관성 지연으로 인하여 입력 변화가 10단위 미만일 경우 출력이 반영이 되지 않음
```

#### 📌 정규 할당 지연의 특징

**지연값 지정**

- `assign` 문에 `#` 키워드를 사용하여 지연값을 직접 지정합니다.

**예제**

```verilog
assign #10 out = a & b; // a와 b의 AND 결과가 10 단위 시간 후에 출력에 반영됨
```

✔ 설명:

- out 신호에 a와 b의 AND 결과를 10 단위 시간 후에 반영합니다.

#### 📌 입력 값 유지 시간의 중요성

- 설명:
    - 입력 신호가 지연 시간보다 짧은 시간 동안만 유지되면, 출력에 영향을 미치지 않을 수 있습니다.
    - 이는 관성 지연과 유사한 동작을 보이며, 입력 신호가 안정된 상태를 유지해야 출력에 반영됩니다.


- 예제:
    ```verilog
    module DelayExample;
        reg a, b;
        wire out;

        assign #10 out = a & b;

        initial begin
            a = 1'b1; b = 1'b1; // a와 b가 1로 설정
            #5 a = 1'b0; // 5 단위 시간 후 a가 0으로 변경
            #10 $display("out = %b", out); // 10 단위 시간 후 out의 값을 출력
        end
    endmodule
    ```
    ✔ 설명:

    - a와 b가 1로 설정된 후, 5 단위 시간 후에 a가 0으로 변경됩니다.

    - 지연 시간이 10 단위이므로, a의 변화는 출력에 영향을 미치지 않습니다.



### 6.2.2. 함축적 연속 할당 지연
✅ Verilog에서 함축적 연속 할당 지연이란?

Verilog의 함축적 연속 할당 지연은 넷 선언과 연속 할당을 한 줄로 작성하면서 지연값을 지정하는 방법입니다.

이는 코드를 간결하게 작성할 수 있게 하며, 정규 할당 지연과 유사한 동작을 제공합니다.

#### 📌 함축적 연속 할당 지연의 특징

1. 지연값 지정

    - 넷 선언과 함께 `#` 키워드를 사용하여 지연값을 지정합니다.

2. 예제:

```verilog
wire #10 out = a & b; // a와 b의 AND 결과가 10 단위 시간 후에 출력에 반영됨
```


✔ 설명:

- out 넷에 a와 b의 AND 결과를 10 단위 시간 후에 반영합니다.

- 기존의 assign 문과 지연값을 따로 지정하는 방식보다 코드가 더 간결합니다.




### 6.2.3. 넷 선언 지연
✅ Verilog에서 넷 선언 지연이란?

Verilog의 넷 선언 지연은 넷 선언 시 지연값을 지정하는 방법입니다. 

이는 넷 선언과 연속 할당을 분리하여 작성할 때 사용되며, 넷에 할당되는 모든 값에 동일한 지연을 적용합니다.

#### 📌 넷 선언 지연의 특징

1. 지연값 지정

    - 넷 선언 시 `#` 키워드를 사용하여 지연값을 지정합니다.

2. 예제:

```verilog
wire #10 out; // out 넷에 10 단위의 지연을 설정
assign out = in1 & in2; // out에 in1과 in2의 AND 결과를 할당
```

✔ 설명:

- `out` 넷에 10 단위의 지연을 설정하여, `in1`과 `in2`의 AND 결과가 `out`에 반영될 때 10 단위 시간이 소요됩니다.


##### 정규 할당 지연, 함축적 연속 할당 지연, 넷 선언 지연

1. 정규 할당 지연
```verilog 
wire out;
assign #10 out = a & b;
```

2. 함축적 연속 할당 지연
```verilog
wire #10 out = a & b;
```

3. 넷 선언 지연

```verilog
wire #10 out; 
assign out = a & b;
```

## 6.3 수식
✅ Verilog에서 수식이란?

Verilog의 `수식`은 데이터 플로우 모델링에서 사용되는 표현식으로, 논리 연산, 산술 연산, 비트 단위 연산 등을 포함합니다.

수식은 `프리미티브 게이트` 수준의 설계가 아닌, `연속 할당(assign) 문`을 통해 신호 간의 관계를 정의하는 데 사용됩니다. 이를 통해 복잡한 
디지털 회로를 간결하고 직관적으로 설계할 수 있습니다.

#### 📌 수식의 주요 특징

1. 연산자와 피연산자

    - 수식은 다양한 연산자(예: &, |, ^, +, -, *, /)와 피연산자(예: 신호, 상수)를 포함합니다.

2. 연속 할당과 함께 사용

    - `assign` 문을 통해 수식을 사용하여 신호 간의 관계를 정의합니다.

3. 조합 논리 회로 모델링

    - 주로 조합 논리 회로를 모델링하는 데 사용되며, 순차 논리 회로에는 적합하지 않습니다.


✅ Verilog에서 수식, 피연산자, 연산자란?

Verilog의 수식은 연산자와 피연산자의 조합으로 구성되며, 데이터 플로우 모델링에서 신호 간의 관계를 정의하는 데 사용됩니다. 

피연산자는 다양한 데이터 형태를 가질 수 있으며, 연산자는 이러한 피연산자를 처리하여 원하는 결과를 생성합니다.

#### 📌 1. 수식

- 설명:
    - 수식은 연산자와 피연산자의 조합으로 이뤄지며, 주로 연속 할당(assign) 문을 통해 사용됩니다.
    - 이를 통해 복잡한 디지털 회로를 간결하게 설계할 수 있습니다.

- 예제:

```verilog
assign out = a & b; // a와 b의 AND 연산 결과를 out에 할당
```
✔ 설명:

- a와 b의 AND 연산 결과를 out에 연속적으로 할당합니다.

#### 📌 2. 피연산자(값)

- 설명:
    - 피연산자는 수식에서 연산자의 대상이 되는 값으로, 다음과 같은 형태를 가질 수 있습니다:

        - 상수: 정수나 문자열 상수

        - 정수: 10진수, 2진수, 8진수, 16진수

        - 실수: 부동소수점 숫자

        - 넷: wire 타입의 신호

        - 레지스터: reg 타입의 변수

        - 시간: 시간 단위로 표현된 값

        - 특정 비트: 벡터의 특정 비트

        - 특정 부분: 벡터의 특정 부분

        - 메모리 함수 호출: 메모리에서 값을 읽어오는 함수 호출

- 예제:

```verilog
wire [7:0] out;
reg [7:0] data;
assign out = data; // 레지스터 data의 값을 넷 out에 할당
```

✔ 설명:
- 레지스터 data의 값을 넷 out에 연속적으로 할당합니다.

#### 📌 3. 연산자(기호)

- 설명:
    - 연산자는 피연산자를 처리하여 원하는 결과를 생성하는 기호입니다.
    - Verilog에서는 다양한 연산자를 제공하며, 다음과 같은 유형이 있습니다:

        - 산술 연산자: +, -, *, /, %, 등

        -  비트 단위 연산자: &, |, ^, ~, 등

        -  논리 연산자: &&, ||, !, 등

        - 비교 연산자: ==, !=, <, >, 등
        
        -  시프트 연산자: <<, >>, 등

-  예제:

```verilog
assign sum = a + b; // a와 b의 덧셈 결과를 sum에 할당
```

✔ 설명:

- a와 b의 덧셈 결과를 sum에 연속적으로 할당합니다.



## 6.4. 연산자 형

### 6.4.1. 산술 연산자
✅ Verilog에서 산술 연산자(Arithmetic Operators)란?

Verilog의 **산술 연산자**는 숫자 간의 기본적인 산술 연산을 수행하는 데 사용됩니다. 

이 연산자는 **이항 연산자**와 **단항 연산자**로 나뉘며, 피연산자의 상태에 따라 결과가 달라질 수 있습니다.


#### 📌이항 산술 연산자

| 연산자 | 의미 | 피연산자 수 |  특이사항 |
|--------|-----|-------------|---|
| `+`    | 덧셈 | 2           ||
| `-`    | 뺄셈 | 2           ||
| `*`    | 곱셈 | 2           ||
| `/`    | 나눗셈 | 2          |나머지는 버림| 
| `%`    | 나머지 | 2          ||
| `**`   | 지수 | 2           ||


**특징**
1. 피연산자 상태에 따른 결과

    - 만약 피연산자 중 하나가 `x` 값을 가지면, 전체 결과는 `x`로 처리됩니다.

2. 나머지 연산자

    - `%` 연산자는 두 수를 나눈 나머지를 반환하며, 첫 번째 피연산자의 부호를 따릅니다.

#### 📌 단항 산술 연산자

1. `+`, `-`의 단항 사용

    - `+`와 `-`는 단항 연산자로도 사용할 수 있으며, 이항 연산자보다 높은 우선순위를 가집니다.

2. 우선순위

    - 단항 연산자의 `+`, `-`는 이항 연산자의 `+`, `-`보다 먼저 평가됩니다.

#### 📌 주의사항

예제 1: 부호 있는 나눗셈

```verilog
-10 / 5 => -2 // 결과 값은 -2가 나옵니다.
```
✔ 설명:

부호 있는 나눗셈에서 -10을 5로 나누면 결과는 -2입니다.

예제 2: 2의 보수 표현 문제

```verilog
-`d10 / 5 => (10의 2의 보수 / 5) => 이상하게 계산이 됩니다.
```

✔ 설명:

2의 보수 표현을 사용할 경우, 부호 있는 숫자의 나눗셈이 예상치 못한 결과를 초래할 수 있습니다.

### 6.4.2. 논리 연산자
### 논리 연산자
✅ Verilog에서 논리 연산자(Logical Operators)란?

Verilog의 논리 연산자는 논리적 조건을 평가하는 데 사용되며, 주로 조합 논리 회로를 모델링하는 데 활용됩니다.

논리 연산자는 NOT, AND, OR 연산을 수행하며, 항상 1비트의 결과를 생성합니다.

#### 📌 논리 연산자 종류

| 연산자 | 의미 | 피연산자 수 |
|--------|-----|-------------|
| `!`    | NOT (부정) | 1           |
| `&&`   | AND (논리곱) | 2           |
| `<code>||</code>`   | OR (논리합) | 2           |

#### 📌 논리 연산자의 특징
1. 결과 비트 수

    - 논리 연산자는 항상 `1비트`의 결과를 생성합니다.

2. 참/거짓 평가

    - 0은 거짓, 1은 참을 나타냅니다.

    - x는 결과가 참 또는 거짓이 아닌 경우 생성되며, 대부분의 시뮬레이터에서는 거짓으로 인식됩니다.

3. 피연산자 평가

    - 피연산자가 `0`이 아닌 경우에는 `1(참)`로 인식합니다.

    - `1`이 아닌 경우 `0(거짓)`으로 인식합니다.

    - `x` 또는 `z`일 때는 `x`의 값으로 인식하며, 대부분의 시뮬레이터에서는 거짓으로 처리됩니다.

4. 피연산자 타입

    - 논리 연산자는 변수 또는 수식을 피연산자로 사용할 수 있습니다.

#### 📌 논리 연산자 사용 예제

예제: 논리 연산자 사용

```verilog
reg a = 1'b1;
reg b = 1'b0;

reg not_a = !a; // NOT 연산: 0
reg and_ab = a && b; // AND 연산: 0
reg or_ab = a || b; // OR 연산: 1

initial begin
    $monitor("a = %b, b = %b -> not_a = %b, and_ab = %b, or_ab = %b", a, b, not_a, and_ab, or_ab);
end

```
✔ 설명:

- `a`와 b의 논리 연산 결과를 `not_a`, `and_ab`, `or_ab`에 할당합니다.
 
- `!a`는 `a`의 부정을 수행하여 `0`을 반환합니다.
 
- `a && b`는 `a`와 `b`의 논리곱을 수행하여 `0`을 반환합니다.
 
- `a || b`는 `a`와 `b`의 논리합을 수행하여 `1`을 반환합니다.



### 6.4.3. 관계 연산자
✅ Verilog에서 관계 연산자(Relational Operators)란?

Verilog의 관계 연산자는 두 피연산자 간의 **대소 관계**를 평가하는 데 사용됩니다. 

이러한 연산자는 두 피연산자의 크기를 비교하여 논리적 참(1) 또는 거짓(0)을 반환합니다.

| 연산자 | 의미 | 피연산자 수 |
|--------|-----|-------------|
| `>`    | 크다 | 2           |
| `<`    | 작다 | 2           |
| `>=`   | 크거나 같다 | 2      |
| `<=`   | 작거나 같다 | 2     |

#### 📌 관계 연산자의 특징

1. 결과 반환

    - 수식의 결과가 참이면 논리적 참(1)을 반환하고, 거짓이면 논리적 거짓(0)을 반환합니다.

2. x와 z 처리

    - 피연산자가 x 또는 z일 경우 결과는 x로 처리됩니다.

#### 📌 관계 연산자 사용 예제

예제: 관계 연산자 사용

```verilog
reg [7:0] a = 8'd10;
reg [7:0] b = 8'd5;

reg gt = a > b; // 크다 비교: 1
reg lt = a < b; // 작다 비교: 0
reg ge = a >= b; // 크거나 같다 비교: 1
reg le = a <= b; // 작거나 같다 비교: 0

initial begin
    $monitor("a = %d, b = %d -> gt = %b, lt = %b, ge = %b, le = %b", a, b, gt, lt, ge, le);
end
```

✔ 설명:

- a와 b의 크기를 비교하여 논리적 결과를 gt, lt, ge, le에 할당합니다.
 
- a > b는 a가 b보다 크므로 결과는 1입니다.
 
- a < b는 a가 b보다 작지 않으므로 결과는 0입니다.
 
- a >= b는 a가 b보다 크거나 같으므로 결과는 1입니다.
 
- a <= b는 a가 b보다 작거나 같지 않으므로 결과는 0입니다.



### 6.4.4. 등가 연산자
✅ Verilog에서 등가 연산자(Equivalence Operators)란?

Verilog의 *등가 연산자*는 두 피연산자 간의 **동일성**을 평가하는 데 사용됩니다. 

#### 📌 등가 연산자 종류

| 연산자 | 의미 | 피연산자 수 | 추가 설명|
|--------|-----|-------------|-----|
| `==`   | 등가 (동일) | 2           |논리 등가 연산자|
| `!=`   | 불등가 (다름) | 2           |논리 부등가|
| `===`  | 등가 (X 무시) | 2           |케이스 등가|
| `!==`  | 불등가 (X 무시) | 2           |케이스 부등가| 

#### 📌 등가 연산자의 특징

1. 논리 등가 연산자 (==, !=)

    - `x` 또는 `z` 값을 가진 피연산자가 있으면 결과는 `x`로 처리됩니다.

    - 가능한 논리 값은 `0`, `1`, `x`입니다.

2. 케이스 등가 연산자 (===, !==)

    - `x`와 `z` 값을 무시하고 비교합니다.

    - 가능한 논리 값은 `0`과 `1`입니다.

####  📌 등가 연산자 사용 예제

예제: 등가 연산자 사용

```verilog
reg [7:0] a = 8'd10;
reg [7:0] b = 8'd5;

reg eq = a == b; // 등가 비교: 0
reg neq = a != b; // 불등가 비교: 1
reg eq_x = a === b; // X 무시 등가 비교: 0
reg neq_x = a !== b; // X 무시 불등가 비교: 1

initial begin
    $monitor("a = %d, b = %d -> eq = %b, neq = %b, eq_x = %b, neq_x = %b", a, b, eq, neq, eq_x, neq_x);
end
```
✔ 설명:

- a와 b의 등가성을 비교하여 논리적 결과를 eq, neq, eq_x, neq_x에 할당합니다.

- a == b는 a와 b가 다르므로 결과는 0입니다.

- a != b는 a와 b가 다르므로 결과는 1입니다.
 
- a === b는 x를 무시하고 비교하므로 결과는 0입니다.
 
- a !== b는 x를 무시하고 비교하므로 결과는 1입니다.


### 6.4.5. 비트 단위 연산자 
✅ Verilog에서 비트 단위 연산자(Bitwise Operators)란?

Verilog의 **비트 단위 연산자**는 각 비트에 대해 독립적으로 연산을 수행하는 데 사용됩니다.

이는 주로 조합 **논리 회로를 모델링**하는 데 활용됩니다.

#### 📌 비트 단위 연산자 종류

| 연산자 | 의미 | 피연산자 수 |
|--------|-----|-------------|
| `~`    | NOT (비트 반전) | 1           |
| `&`    | AND (비트 논리곱) | 2           |
| `\|`    | OR (비트 논리합) | 2           |
| `^`    | XOR (비트 배타적 논리합) | 2           |
| `~&`   | NAND (비트 논리곱의 부정) | 2           |
| `~\|`   | NOR (비트 논리합의 부정) | 2           |
| `~^`   | XNOR (비트 배타적 논리합의 부정) | 2           |


#### 📌 비트 단위 연산자의 특징

1. 비트 수에 따른 연산

    - 피연산자의 비트 수만큼 연산을 수행합니다.

    - 만약 하나의 피연산자가 다른 피연산자보다 짧을 경우, 나머지 부분은 0으로 채워 연산합니다.

2. x와 z 처리

    - x와 z 값은 x로 취급됩니다.

3. 비트 연산자와 논리 연산자의 차이

    - 비트 연산자는 각 비트에 대해 독립적으로 연산을 수행합니다.

    - 논리 연산자는 전체 피연산자를 하나의 논리적 값으로 처리합니다.

#### 📌 비트 단위 연산자 사용 예제

예제: 비트 단위 연산자 사용

```verilog
reg [7:0] a = 8'b10101010;
reg [7:0] b = 8'b11001100;

reg [7:0] not_a = ~a; // NOT 연산: 01010101
reg [7:0] and_ab = a & b; // AND 연산: 10001000
reg [7:0] or_ab = a | b; // OR 연산: 11101110
reg [7:0] xor_ab = a ^ b; // XOR 연산: 01100110

initial begin
    $monitor("a = %b, b = %b -> not_a = %b, and_ab = %b, or_ab = %b, xor_ab = %b", a, b, not_a, and_ab, or_ab, xor_ab);
end
```

✔ 설명:

- a와 b의 비트 단위 연산 결과를 not_a, and_ab, or_ab, xor_ab에 할당합니다.
 
- ~a는 a의 비트를 반전하여 01010101을 반환합니다.
 
- a & b는 a와 b의 비트 논리곱을 수행하여 10001000을 반환합니다.

- a | b는 a와 b의 비트 논리합을 수행하여 11101110을 반환합니다.
 
- a ^ b는 a와 b의 비트 배타적 논리합을 수행하여 01100110을 반환합니다.




### 6.5.6. 축소 연산자
✅ Verilog에서 축소 연산자(Reduction Operators)란?

Verilog에서 **축소 연산자**는 **벡터**를 **단일 비트**로 줄이는 데 사용됩니다.

| 연산자 | 의미 | 피연산자 수 |
|--------|-----|-------------|
| `&`    | AND (모든 비트 논리곱) | 1           |
| `~&`   | NAND (모든 비트 논리곱의 부정) | 1           |
| `\|`    | OR (모든 비트 논리합) | 1           |
| `~\|`   | NOR (모든 비트 논리합의 부정) | 1           |
| `^`    | XOR (모든 비트 배타적 논리합) | 1           |
| `~^`   | XNOR (모든 비트 배타적 논리합의 부정) | 1           |

#### 📌 축소 연산자의 특징

1. 축소 연산자의 동작

    - `&`는 벡터의 모든 비트가 1일 때만 결과가 1입니다.
    - `~&`는 `&`의 반대값을 반환합니다.

    - `|`는 벡터의 비트 중 하나라도 1이면 결과가 1입니다.

    - `~|`는 `|`의 반대값을 반환합니다.

    - `^`는 벡터의 비트 중 홀수 개가 1일 때 결과가 1입니다.

    - `~^`는 `^`의 반대값을 반환합니다.

2. XOR/XNOR의 패리티 검사 활용

    - `^`와 `~^`는 벡터의 짝/홀수 패리티를 검사하는 데 사용됩니다.

    - `^`는 홀수 개의 비트가 1일 때 1을 반환하며, 이는 홀수 패리티를 나타냅니다.

    - `~^`는 짝수 개의 비트가 1일 때 1을 반환하며, 이는 짝수 패리티를 나타냅니다.

#### 📌 축소 연산자 사용 예제
예제: 축소 연산자 사용

```verilog
reg [3:0] A = 4'b1101;
reg B;

B = &A; // AND 축소: 0 (모든 비트가 1이 아니므로)
B = ~&A; // NAND 축소: 1 (AND의 반대값)
B = |A; // OR 축소: 1 (비트 중 하나라도 1이므로)
B = ~|A; // NOR 축소: 0 (OR의 반대값)
B = ^A; // XOR 축소: 1 (홀수 개의 비트가 1이므로)
B = ~^A; // XNOR 축소: 0 (XOR의 반대값)

initial begin
    $monitor("A = %b -> B = %b", A, B);
end
```

✔ 설명:
 
- A 벡터의 모든 비트에 대해 축소 연산을 수행하여 결과를 B에 할당합니다.
 
- &A는 모든 비트가 1이 아니므로 결과는 0입니다.
 
- ~&A는 &A의 반대값을 반환하여 결과는 1입니다.
 
- |A는 비트 중 하나라도 1이므로 결과는 1입니다.
 
- ~|A는 |A의 반대값을 반환하여 결과는 0입니다.

- ^A는 홀수 개의 비트가 1이므로 결과는 1입니다.
 
- ~^A는 짝수 개의 비트가 1일 때 1을 반환하여 결과는 0입니다.


### 6.4.7. 자리 이동 연산자
✅ Verilog에서 자리 이동 연산자(Shift Operators)란?

Verilog에서 **자리 이동 연산자(Shift Operators)**는 **비트를 왼쪽이나 오른쪽으로 이동**하는 데 사용됩니다.

#### 📌 자리 이동 연산자 종류
| 연산자 | 의미 | 피연산자 수 |
|--------|-----|-------------|
| `<<`   | 논리적 왼쪽 이동 (0으로 채움) | 2           |
| `>>`   | 논리적 오른쪽 이동 (0으로 채움) | 2           |
| `<<<`  | 산술적 왼쪽 이동 (부호 유지) | 2           |
| `>>>`  | 산술적 오른쪽 이동 (부호 유지) | 2           |

#### 📌 자리 이동 연산자의 특징

1. 논리적 자리 이동

    - `<<`는 왼쪽으로 이동하며, 빈 자리는 0으로 채웁니다.

    - `>>`는 오른쪽으로 이동하며, 빈 자리는 0으로 채웁니다.

2. 산술적 자리 이동

    - `<<<`는 왼쪽으로 이동하며, 부호 비트를 유지합니다.

    - `>>>`는 오른쪽으로 이동하며, 부호 비트를 유지합니다.

3. 비트 채우기

    - 자리 이동을 하는 동안 비게 되는 비트들은 모두 0으로 채워집니다.

4. 회전 자리 이동 없음

    - Verilog의 자리 이동 연산자는 회전 자리 이동을 지원하지 않습니다.

#### 📌 자리 이동 연산자 사용 예제

예제 1: 논리적 자리 이동

```verilog
reg [7:0] a = 8'b00001111; //일 때

reg [7:0] left_shift = a << 2; // 논리적 왼쪽 이동: 00111100
reg [7:0] right_shift = a >> 2; // 논리적 오른쪽 이동: 00000011

initial begin
    $monitor("a = %b -> left_shift = %b, right_shift = %b", a, left_shift, right_shift);
end
```

✔ 설명:

- a의 비트를 왼쪽으로 2자리 이동하여 `left_shift`에 할당합니다.

- a의 비트를 오른쪽으로 2자리 이동하여 `right_shift`에 할당합니다.

예제 2: 산술적 자리 이동

```verilog
reg signed [7:0] b = -8'd10; // 부호 있는 변수

reg signed [7:0] left_shift_arithmetic = b <<< 2; // 산술적 왼쪽 이동
reg signed [7:0] right_shift_arithmetic = b >>> 2; // 산술적 오른쪽 이동

initial begin
    $monitor("b = %d -> left_shift_arithmetic = %d, right_shift_arithmetic = %d", b, left_shift_arithmetic, right_shift_arithmetic);
end
```

✔ 설명:

- b의 비트를 왼쪽으로 2자리 산술적으로 이동하여 `left_shift_arithmetic`에 할당합니다.

- b의 비트를 오른쪽으로 2자리 산술적으로 이동하여 `right_shift_arithmetic`에 할당합니다.

예제 3: shift-and-add 알고리즘

```verilog
integer a, b, c;
a = 0;
b = -10; // 2의 보수 표현

c = a + (b >>> 3); // -2

initial begin
    $monitor("b = %d, c = %d", b, c);
end
```

✔ 설명:

- b를 오른쪽으로 3자리 이동한 후 a에 더하여 c에 할당합니다.

- 이는 shift-and-add 알고리즘을 통해 곱셈을 구현하는 예입니다.

### 6.4.8. 결합 연산자
✅ Verilog에서 결합 연산자(Concatenation Operator)란?

Verilog에서 **결합 연산자(Concatenation Operator)**는 두 개 이상의 **벡터**나 **표현식**을 하나의 **벡터**로 결합하는 데 사용됩니다.

이는 중괄호 {}를 사용하여 여러 비트나 벡터를 하나로 결합합니다.

#### 📌 결합 연산자의 특징

1. 중괄호 {} 사용

    - 여러 벡터나 표현식을 중괄호 {} 안에 나열하여 결합합니다.

2. 벡터 결합


    - 결합된 벡터의 비트 수는 각 피연산자의 비트 수의 합입니다.

3. 예제:

```verilog
reg [7:0] c; // 8비트 벡터
reg [4:0] a = 5'b11111; // 5비트 벡터
reg [2:0] b = 3'b000; // 3비트 벡터

assign c = {a, b}; // c = "11111000"
```

✔ 설명:

- a와 b를 결합하여 c에 할당합니다.

- a는 5비트, b는 3비트이므로 결합된 c는 8비트가 됩니다.


### 6.4.9. 중복 연산자
✅ Verilog에서 중복 연산자(Replication Operator)란?

Verilog에서 **중복 연산자(Replication Operator)**는 **중괄호 `{}`**를 사용하여 **하나의 표현식을 여러 번 반복**하는 데 사용됩니다.

이는 주로 벡터를 확장하거나 반복 패턴을 생성하는 데 활용됩니다.

#### 📌 중복 연산자의 특징

1. 중괄호 {} 사용

    - `{반복 횟수{표현식}}` 형식으로 사용됩니다.

2. 반복 횟수

    - 반복 횟수는 **상수**로 지정되어야 합니다.

    - 변수를 사용하면 컴파일 에러가 발생합니다.

3. X와 Z 값 사용 제한

    - 반복 연산에서 `x`와 `z` 값은 사용할 수 없습니다.

#### 📌 중복 연산자 사용 예제

예제: 중복 연산자 사용
```verilog
reg a;
reg [1:0] b, c;
reg [2:0] d;

a = 1'b1; b = 2'b00; c = 2'b10; d = 3'b110;

reg [7:0] Y;
assign Y = {4{a}, 2{b}}; // Y = 8'b11110000

initial begin
    $monitor("Y = %b", Y);
end
```

✔ 설명:

- a를 4회 반복하고 b를 2회 반복하여 Y에 할당합니다.

- 결과는 11110000입니다.


### 6.4.10. 조건 연산자
✅ Verilog에서 조건 연산자(Conditional Operator)란?

Verilog에서 **조건 연산자(Conditional Operator)**는 **조건에 따라 값을 선택**하는 데 사용됩니다.

이는 조건식, 참 조건 시 반환할 값, 거짓 조건 시 반환할 값으로 구성되며, 조건식의 결과에 따라 적절한 값을 반환합니다.
 
#### 📌 조건 연산자의 구조

```verilog
condition ? true_expression : false_expression
condition: 조건을 평가하는 표현식입니다.
```

- **condition**: 조건을 평가하는 **표현식**입니다.

- **true_expression**: 조건이 참일 때 반환할 **값**입니다.

- **false_expression**: 조건이 거짓일 때 반환할 **값**입니다.

####📌 조건 연산자의 특징

1. 조건식 평가

    - 조건식의 결과가 x일 경우, 참 조건 시 수식과 거짓 조건 시 수식을 모두 실행하여 비트 단위로 비교합니다.

    - 각 비트가 서로 다른 경우 해당 비트는 x로 처리됩니다.

2. 멀티플렉서와의 유사성

    - 조건 연산자는 멀티플렉서의 기능과 유사하며, 조건에 따라 입력을 선택하는 역할을 합니다.

3. if-else와의 유사성

    - 조건 연산자는 if-else 문과 비슷한 기능을 제공하며, 조건에 따라 값을 선택합니다.

####  📌 조건 연산자 사용 예제

예제: 조건 연산자 사용

```verilog
reg [7:0] a = 8'd10;
reg [7:0] b = 8'd20;
reg [7:0] result;

assign result = (a > b) ? a : b; // a가 b보다 크면 a를 반환, 아니면 b를 반환

initial begin
    $monitor("a = %d, b = %d -> result = %d", a, b, result);
end
```
