---
title: "[베릴로그 HDL] 08. 태스크 및 함수"
date: 2025-03-20 01:20:00 +09:00
categories: [Verilog, 베릴로그공부]
tags:
  [
    verilog,
    systemverilog,
    Vivado,
    Vitis
  ]
---


# 8. 태스크와 함수

## 목표
1. 태스크와 함수의 차이점 이해하기
2. 태스트를 정의하기 위해 필요한 조건을 확인, 태스크 선언과 호출 이해하기
3. 함수를 정의하기 위해 필요한 조건들을 확인하고, 함수 선언과 호출 이해하기

## 8.1. 태스크와 함수의 차이점

Verilog에서 **태스크(Task)**와 **함수(Function)**는 코드의 중복을 줄이고, 유지보수성을 높이는 데 사용됩니다. 

두 가지의 주요 차이점은 다음과 같습니다:

1. 시간 제어
    - **태스크(Task)**: 0이 아닌 시뮬레이션 시간에 수행될 수 있다.
        - `#`, `@`, `wait`, `posedge`, `negedge` 등의 지연 명령어를 사용할 수 있다.
    - **함수(Function)**: 항상 시뮬레이션 시간 0에 수행된다.

2. 반환 값
    - **태스크(Task)**: 반환 값을 가지지 않는다. 
        - 대신 **output** 또는 **inout** 포트를 통해 값을 반환한다.
    - **함수(Function)**: 단일 반환 값을 가질 수 있다.
        - 이는 **expression** 형태로 반환된다.

3. 호출 및 사용
    - **태스크(Task)**: 절차적 문맥에서만 호출할 수 있으며, 다른 태스크나 함수를 호출할 수 있다.
    - **함수(Function)**: 표현식 내에서 호출할 수 있으며, 다른 함수만 호출할 수 있다.

4. 변수 범위
    - **태스크(Task)**: 내부에서 선언된 변수는 태스크 내에서만 유효하며, 외부 변수를 수정할 수 있다.
    - **함수(Function)**: 내부에서 선언된 변수는 함수 내에서만 유효하며, 외부 변수를 수정할 수 있다.


## 8.2. 태스크
✅Verilog에서 태스크(Task)

Verilog의 **태스크(Task)**는 키워드 `task`와 `endtask`를 사용하여 선언되며, 주로 프로시저적 작업을 수행하고, 시뮬레이션에서 복잡한 작업을 처리하는 데 사용됩니다. 

태스크는 시간 지연, 다중 출력, 사건 제어 등을 포함할 수 있어 테스트벤치 및 시뮬레이션 작업에 적합합니다.

#### 📌 태스크 사용 조건
태스크는 다음 조건 중 하나라도 참일 경우 사용해야 합니다:

1. 시간 지연 또는 사건 제어 구조 포함

    - 태스크는 `#`, `@`, `wait`, `posedge`, `negedge`와 같은 타이밍 제어를 포함할 수 있습니다.

2. 출력 인수 포함

    - 태스크는 하나 이상의 출력(`output`) 또는 입출력(`inout`) 인수를 가질 수 있습니다.

3. 입력 인수 없이 동작 가능

    - 태스크는 입력(input) 인수가 없어도 동작할 수 있습니다.

#### 📌태스크(Task) vs. 모듈(Module): 기본적인 차이점

| 구분              | 태스크(Task)                        | 모듈(Module)                         |
|-----------------|--------------------------------|--------------------------------|
| **사용 범위**      | 비절차적(조합/순차 논리) 및 시뮬레이션 | 하드웨어 설계(논리 회로 구현) |
| **시간 지연 (#delay)** | ✅ 사용 가능                         | ❌ 사용 불가 (시뮬레이션에서만 가능) |
| **재사용성**      | 같은 모듈 내에서 재사용               | 여러 모듈에서 인스턴스화하여 재사용 |
| **실행 방식**      | 프로시저 내에서 호출 (순차적 실행 가능) | 하드웨어적으로 인스턴스화 (병렬 실행) |
| **다중 출력**      | `output`을 사용해 다중 값 반환 가능   | 여러 포트를 통해 데이터 전달 가능 |
| **연산 방식**      | 순차적 또는 조합 논리                 | 하드웨어 블록으로 동작 (병렬 연산 가능) |
| **합성 가능 여부** | ❌ 합성 불가능       | ✅ 합성 가능       


#### 태스크 예제

**예제 1**: 기본 태스크

```verilog
task add_values;
    input [7:0] a, b;
    output [7:0] result;
    begin
        #10; // 시간 지연 포함
        result = a + b;
    end
endtask

initial begin
    reg [7:0] sum;
    add_values(8'd5, 8'd10, sum); // 태스크 호출
    $display("Sum = %d", sum);
end
```

✔ 설명:

- add_values 태스크는 두 입력 값을 더하고 결과를 출력합니다.

- 시간 지연(#10)을 포함하여 실행됩니다.

**예제 2**: 사건 기반 태스크

```verilog
task wait_for_signal;
    input signal;
    begin
        @(posedge signal); // 신호의 상승 에지 대기
        $display("Signal detected!");
    end
endtask

initial begin
    reg clk = 0;
    forever #5 clk = ~clk; // 클럭 생성
    wait_for_signal(clk); // 태스크 호출
end
```

✔ 설명:

- wait_for_signal 태스크는 특정 신호의 상승 에지를 기다린 후 메시지를 출력합니다.


### 8.2.1. 태스크 선언과 호출
✅Verilog에서 태스크(Task) 선언과 호출

Verilog의 **태스크(Task)**는 복잡한 연산이나 시간 의존적인 작업을 수행하기 위해 사용되며, 시간 제어, 다중 출력, 절차적 호출 등을 지원합니다. 태스크는 `task와` `endtask` 키워드로 정의됩니다.



#### 📌 1. 시간 제어
- 설명
    - 태스크는 `#`, `@`, `wait`, `posedge`, `negedge` 등의 지연 명령어를 사용하여 시간 제어를 포함할 수 있다.

- 예시:
    ```verilog
    task my_task;
        #10; // 10 시간 단위 후에 실행
        output_signal = 1'b1;
    endtask
    ```

    ✔ 설명:

    - 태스크는 10 시간 단위의 지연 후에 `output_signal`을 설정합니다.


#### 📌 2. 반환 값
- 설명:
    - **태스크는 반환 값을 가지지 않으며**, 대신 `output` 또는 `inout` 포트를 통해 값을 반환한다.

- 예시:
    ```verilog
    task my_task(output reg [7:0] result);
        result = 8'd10; // output 포트를 통해 값을 반환
    endtask
    ```

    ✔ 설명:

    - 태스크는 result를 출력 포트를 통해 반환합니다.

#### 📌 3. 호출 및 사용
- 설명:
    - 태스크는 절차적 문맥에서만 호출할 수 있으며, 다른 태스크나 함수를 호출할 수 있습니다.

- 예시:
    ```verilog
    initial begin
        reg [7:0] result;
        my_task(result); // 태스크 호출
        $display("Result = %d", result);
    end
    ```
    ✔ 설명:

    - my_task 태스크를 호출하여 결과를 출력합니다.


#### 📌 4. 변수 범위
- 설명:
    - 태스크 내에서 선언된 변수는 태스크 내에서만 유효하며, 외부 변수를 수정할 수 있습니다.


2. 예시:
    ```verilog
    task my_task;
        reg temp; // 태스크 내에서만 유효한 변수
        temp = 1'b1;
        output_signal = temp; // 외부 변수 수정
    endtask
    ```

    ✔ 설명:

    - `temp` 변수는 태스크 내에서만 유효하며, 이를 사용하여 외부 변수 `output_signal`을 수정합니다.

#### 📌 Verilog 태스크 선언과 호출 특징

| 항목                  | 설명                                                                 |
|-----------------------|---------------------------------------------------------------------|
| 시간 제어 지원         | ✅ 타이밍 제어(`#`, `@`, `wait`)를 포함할 수 있음                     |
| 반환 값 방식           | ❌ 직접 반환값 없음 (대신 `output` 또는 `inout` 포트를 통해 값 반환)   |
| 절차적 호출 가능       | ✅ 절차적 문맥(`initial`, `always`)에서 호출 가능                     |
| 변수 범위 제한         | ✅ 내부 변수는 태스크 내에서만 유효하며, 외부 변수를 수정 가능          |
| 활용 목적             | 복잡한 작업 처리 및 테스트벤치 작성에 유용                             |




### 8.2.3. 재진입 태스크
✅Verilog에서 재진입 태스크 (Reentrant Task)

Verilog에서 태스크는 기본적으로 **정적(static) 변수**를 사용합니다.
 따라서, 여러 스레드에서 동일한 태스크를 동시에 호출하면 변수 값이 공유되어 **값이 덮어씌워질 위험**이 있습니다. 이를 방지하기 위해 **`automatic` 태스크**를 사용하여 재진입이 가능하도록 설계할 수 있습니다
---

#### 📌 왜 재진입 태스크가 필요할까?
1. 병렬 실행 (Fork-Join)

    - Verilog는 fork-join을 사용하여 여러 프로세스를 병렬로 실행할 수 있습니다.

    - 같은 태스크를 동시에 실행해야 하는 경우, `automatic` 태스크를 사용하면 각 호출이 독립적으로 실행됩니다.

2. 멀티스레드 환경에서 변수 충돌 방지

    - 일반 태스크는 변수 값을 공유하므로 동시에 실행되면 값이 덮어씌워질 위험이 있습니다.

    - `automatic`을 사용하면 각 실행마다 개별적인 변수 공간을 할당받습니다.

3. 반복적인 연산 처리

    - 병렬 데이터 처리에서 각각의 연산이 독립적으로 실행되어야 한다면 `automatic` 태스크가 적합합니다.

#### 📌 재진입 가능 vs 불가능한 태스크 비교

| 구분               | 재진입 가능 (Automatic task)  | 재진입 불가능 (Static task)  |
|-------------------|---------------------------|---------------------------|
| **정의 방식**      | `automatic task` 사용      | `task` (기본값) 사용       |
| **변수 저장 방식**  | 스택(Stack) 메모리 사용    | 정적(Static) 메모리 사용   |
| **동시 호출 가능 여부** | ✅ 가능 (각각 독립 실행)   | ❌ 불가능 (공유된 변수 사용) |
| **각 호출 간 간섭**  | ❌ 없음 (독립적인 변수 할당) | ✅ 있음 (변수 공유됨)       |
| **사용 사례**      | 멀티스레드 환경, 병렬 실행 | 순차적 실행이 필요한 경우  |

#### 📌 재진입 태스크 예제

**예제 1**: 기본 Static Task (재진입 불가능)

```verilog
task static_task;
    integer shared_var; // 정적 메모리 사용
    begin
        shared_var = shared_var + 1;
        $display("Shared Variable = %d", shared_var);
    end
endtask

initial begin
    fork
        static_task(); // 첫 번째 호출
        static_task(); // 두 번째 호출
    join
end
```

✔ 설명:

- 두 스레드가 동일한 `shared_var`를 공유하므로 값이 덮어씌워져 결과가 예상과 다를 수 있습니다

**예제 2**: Automatic Task (재진입 가능)

```verilog
automatic task reentrant_task;
    integer local_var; // 독립적인 메모리 공간 할당
    begin
        local_var = local_var + 1;
        $display("Local Variable = %d", local_var);
    end
endtask

initial begin
    fork
        reentrant_task(); // 첫 번째 호출 (독립적 실행)
        reentrant_task(); // 두 번째 호출 (독립적 실행)
    join
end
```

✔ 설명:

- 각 호출은 독립적인 메모리 공간을 가지므로, 변수 간 간섭 없이 병렬로 안전하게 실행됩니다.

#### 📌 재진입 태스크 작성 시 주의사항
1. automatic 키워드 사용

    - 재진입 가능한 태스크를 정의하려면 반드시 `automatic task`로 선언해야 합니다.

2. 변수 저장 방식

    - `automatic` 태스크는 스택(`Stack`) 메모리를 사용하여 각 호출에 대해 독립적인 변수 공간을 제공합니다.

3. 병렬 환경에서 안전성 보장

    - 멀티스레드 환경이나 병렬 작업 시 변수 충돌을 방지합니다.

#### 📌 Verilog 재진입 태스크 특징

| 항목                  | 설명                                                                 |
|-----------------------|---------------------------------------------------------------------|
| 정의 방식             | `automatic task`를 사용하여 재진입 가능하도록 설계                   |
| 변수 저장 방식         | 스택(Stack) 메모리를 사용하여 각 호출마다 독립적인 공간 제공          |
| 동시 호출 가능 여부    | ✅ 가능 (병렬 작업 시 안전성 보장)                                     |
| 활용 목적             | 멀티스레드 환경, 병렬 데이터 처리, 반복적인 연산 수행                 |





## 8.3. 함수
✅Verilog에서 함수(Function)

Verilog의 **함수(Function)**는 키워드 `function`과 `endfunction`으로 선언되며, 주로 단일 값 반환을 위한 간단한 계산이나 논리 연산을 수행하는 데 사용됩니다. 

함수는 시간 지연, 타이밍 제어, 또는 사건 제어를 포함할 수 없으며, 순수하게 조합 논리로 동작합니다.

#### 📌 함수를 사용할 조건

함수는 다음 조건이 모두 참일 때 허용됩니다:

1. 시간 지연, 타이밍, 사건 제어 없음

    - 함수는 `#`, `@`, `wait`, `posedge`, `negedge` 등을 포함할 수 없습니다.

2. 단일 반환값

    - 함수는 하나의 값을 반환해야 하며, 여러 값을 반환할 수 없습니다.

3. 입력 인자 필수

    - 함수는 일반적으로 하나 이상의 입력(input) 인자를 가지지만, 입력 인자 없이 정의하는 것도 가능합니다."

4. output 및 inout 인자 없음

    - 함수는 `output` 또는 `inout` 인자를 사용할 수 없습니다.

5. 논블로킹 할당 없음

    - 함수 내부에서는 논블로킹 할당(`<=`)을 사용할 수 없습니다.

#### 📌 Verilog 함수의 특징

| 특징             | 설명                                      |
|----------------|-----------------------------------------|
| **반환값 개수**    | 하나의 값만 반환 가능 (return 키워드 없음)    |
| **시간 지연 (`#delay`)** | ❌ 사용 불가                               |
| **블로킹 할당 (`=`)** | ✅ 사용 가능                               |
| **비블로킹 할당 (`<=`)** | ❌ 사용 불가                               |
| **변수 선언**      | `input`만 허용, `output` 사용 불가           |
| **재사용성**       | 모듈 내에서 여러 번 호출 가능               |
| **합성 가능 여부**  | ✅ 가능 (순수 조합 논리일 경우)              |


#### 📌 함수 선언과 호출

1. 함수 선언
    
    ```verilog
    function [7:0] add_values;
        input [7:0] a, b; // 입력 인자
        begin
            add_values = a + b; // 단일 값 반환
        end
    endfunction
    ```
    
    ✔ 설명:

    - `add_values` 함수는 두 입력 값을 더한 결과를 반환합니다.

2. 함수 호출

    ```verilog
    module FunctionExample;
        reg [7:0] result;

        initial begin
            result = add_values(8'd10, 8'd20); // 함수 호출
            $display("Result = %d", result);
        end

        function [7:0] add_values;
            input [7:0] a, b;
            begin
                add_values = a + b; // 단일 값 반환
            end
        endfunction
    endmodule
    ```

    ✔ 설명:

    - `add_values` 함수를 호출하여 두 숫자를 더한 결과를 출력합니다.


#### 📌 함수 작성 시 주의사항
1. 단일 반환값 제한

    - 함수는 항상 하나의 값을 반환해야 하며, 여러 값을 반환할 수 없습니다.

2. 시간 지연 금지

    - 함수 내부에서는 시간 지연(`#delay`)이나 사건 제어(`@`,` wait`)를 사용할 수 없습니다.

3. 논블로킹 할당 금지

    - 함수 내부에서는 논블로킹 할당(`<=`)을 사용할 수 없습니다.

4. 입력 인자 필수

    - 함수는 적어도 하나 이상의 입력(`input`) 인자를 가져야 합니다.

5. 모듈 내 재사용 가능성

    - 함수는 모듈 내에서 여러 번 호출하여 재사용할 수 있습니다.



### 8.3.1. 함수 선언과 호출
✅Verilog에서 함수(Function) 선언과 호출

Verilog의 **함수(Function)**는 단일 값을 반환하며, 간단한 계산이나 논리 연산을 수행하는 데 사용됩니다. 

함수는 `function`과 `endfunction` 키워드를 사용하여 선언되며, 표현식 내에서 호출할 수 있습니다.

#### 📌 1. 단일 반환 값
- 설명:
    - 함수는 단일 반환 값을 가지며, 반환 값은 함수 이름을 통해 설정됩니다.
    - Verilog 내부적으로 함수 이름은 묵시적으로 선언된 레지스터로 간주됩니다.

- 예시:

    ```verilog
    function [7:0] my_function;
        my_function = 8'd10; // 단일 반환 값 설정
    endfunction
    ```

    ✔ 설명:

    - `my_function`은 단일 값을 반환하며, 반환 값은 `8'd10`으로 설정됩니다.


#### 📌 2. 시간 제어 불가

- 설명:
    - 함수는 시간 지연, 사건 제어, 또는 타이밍 제어를 포함할 수 없습니다.
    - 즉, `#`, `@`, `wait`, `posedge`, `negedge`와 같은 명령어를 사용할 수 없습니다.

- 예시:

    ```verilog
    function [7:0] my_function;
        // 시간 제어 불가
        my_function = 8'd10;
    endfunction
    ```

    ✔ 설명:

    - 함수 내부에서는 시간 지연 명령어를 사용할 수 없습니다.

#### 📌 3. 호출 및 사용

- 설명:
    - 함수는 표현식 내에서 호출할 수 있으며, 다른 함수만 호출할 수 있습니다.
    - 절차적 문맥(`always`, `initial`)에서 주로 사용됩니다.

- 예시:

    ```verilog
    reg [7:0] result;

    always @(posedge clk) begin
        result = my_function(); // 함수 호출
    end

    function [7:0] my_function;
        my_function = 8'd42; // 반환 값 설정
    endfunction
    ```
    ✔ 설명:

    - 클럭 상승 에지에서 `my_function`을 호출하여 결과를 `result`에 저장합니다.

#### 📌 4. 변수 범위

- 설명:
    - 함수 내에서 선언된 변수는 함수 내부에서만 유효하며, 외부 변수를 수정할 수 없습니다.
    - 함수는 독립적인 변수 공간을 가지며, 외부 변수와 간섭하지 않습니다.

- 예시:

    verilog
    function [7:0] my_function;
        reg [7:0] temp; // 함수 내에서만 유효한 변수
        temp = 8'd10;   // 임시 변수 설정
        my_function = temp; // 반환 값 설정
    endfunction
    ✔ 설명:

    - temp 변수는 함수 내부에서만 유효하며, 이를 통해 반환 값을 설정합니다.


#### 📌 Verilog 함수 특징

| 항목                  | 설명                                                                 |
|-----------------------|---------------------------------------------------------------------|
| 단일 반환 값 제한      | 하나의 값만 반환 가능                                              |
| 시간 제어 금지         | ❌ 시간 지연 포함 불가                                              |
| 표현식 내 호출 가능     | ✅ 표현식의 일부로 호출 가능                                        |
| 변수 범위 제한         | ✅ 내부 변수는 함수 내에서만 유효                                    |
| 활용 목적             | 간단한 계산, 논리 연산 등 즉시 실행 가능한 작업                     |






### 8.3.3. 자동(재귀)함수
✅Verilog에서 자동(재귀) 함수 (Automatic Function)

Verilog의 **자동 함수(Automatic Function)**는 automatic 키워드를 사용하여 선언되며, 재귀 호출을 지원합니다.

함수 호출 시마다 새로운 메모리 공간을 동적으로 할당하여 이전 호출의 데이터를 보호하므로, 동일한 함수가 여러 번 호출되거나 재귀적으로 호출될 때 데이터 충돌을 방지할 수 있습니다.

📌 **자동(재귀) 함수의 특징**

| **특징**               | **설명**                                                                 |
|-------------------------|-------------------------------------------------------------------------|
| **Automatic 키워드**    | 재귀 호출을 지원하며, 호출 시마다 새로운 메모리 공간을 생성합니다.          |
| **메모리 관리**         | 각 호출마다 독립적인 메모리 공간이 할당되며, 호출 종료 시 해제됩니다.        |
| **재진입 가능성**       | 동일한 함수가 여러 프로세스에 의해 동시에 실행될 때 안전하게 동작합니다.      |
| **합성 가능 여부**      | ✅ 가능 (조합 논리일 경우), 하지만 재귀는 주로 시뮬레이션에서 사용됩니다.       |
| **기본 제한**           | 재귀 호출 횟수는 기본적으로 64번으로 제한되며, 설정 변경 가능 (`-recursion_iteration_limit`) |



#### 📌 자동 함수 선언과 사용
1. 자동 함수 선언
    ```verilog
    function automatic [31:0] factorial;
        input [31:0] n;
        begin
            if (n == 0)
                factorial = 1; // 종료 조건
            else
                factorial = n * factorial(n - 1); // 재귀 호출
        end
    endfunction
    ```
    ✔ 설명:

    - `factorial` 함수는 `automatic`으로 선언되어 재귀적으로 호출됩니다.

    - 각 호출은 독립적인 메모리 공간을 가지므로 데이터 충돌이 발생하지 않습니다


2. 자동 함수 호출
    ```verilog
    module AutomaticFunctionExample;
        reg [31:0] result;

        initial begin
            result = factorial(5); // 5! = 120
            $display("Factorial of 5 = %d", result);
        end

        function automatic [31:0] factorial;
            input [31:0] n;
            begin
                if (n == 0)
                    factorial = 1; // 종료 조건
                else
                    factorial = n * factorial(n - 1); // 재귀 호출
            end
        endfunction
    endmodule
    ```
    ✔ 설명:

    - factorial 함수를 호출하여 결과를 계산하고 출력합니다.

#### 📌 자동 함수 작성 시 주의사항

1. Automatic 키워드 필수

    - 재귀를 지원하려면 반드시 automatic 키워드를 사용해야 합니다.

2. 메모리 관리
    
    - 각 호출마다 독립적인 메모리 공간이 동적으로 생성됩니다.

3. 재진입 가능성 보장

    - 동일한 함수가 여러 스레드에서 동시에 실행될 경우에도 안전하게 동작합니다.

4. 재귀 제한 설정

    - 기본적으로 재귀 호출 횟수는 64번으로 제한되며, 필요시 컴파일러 옵션으로 변경 가능합니다 (-recursion_iteration_limit).

5. 합성 가능 여부

    - 조합 논리를 사용하는 경우 합성이 가능하지만, 재귀는 일반적으로 시뮬레이션에서만 사용됩니다.




### 8.3.4. 상수 함수
✅Verilog에서 상수 함수(Constant Function)

Verilog의 상수 함수는 설계의 *정교화 단계(elaboration time)*에서 실행되며, 주로 **파라미터 계산** 및 **모듈 생성**에 사용됩니다.

이러한 함수는 입력값이 상수일 경우 항상 동일한 결과를 반환하며, 시간 제어나 전역 변수 수정은 포함할 수 없습니다.

#### 📌 상수 함수의 특징

1. 상수 입력만 허용

    - 상수 함수는 입력으로 상수 값만을 허용합니다.

    - 이는 정교화 단계에서 평가되기 때문입니다.

2. Elaboration Time 평가

    - 상수 함수는 시뮬레이션 시작 전에, 즉 정교화 단계에서 모든 상수 표현식이 평가됩니다.

3. 시간 제어 불가

    - 상수 함수는 시간 지연(#, @, wait)을 포함할 수 없습니다.

    - 모든 연산은 한 시간 단위 내에 완료되어야 합니다.

#### 📌 상수 함수 사용 예제

1. 상수 입력만 허용

    ```verilog
    function [7:0] my_function;
        input [7:0] n;
        begin
            my_function = n + 8'd10; // n은 상수여야 함
        end
    endfunction
    ```

    ✔ 설명:

    - my_function은 입력값 n에 10을 더한 결과를 반환합니다.

    - `n`은 반드시 상수여야 합니다.

2. Elaboration Time 평가

    ```verilog
    parameter size = my_function(8'd10); // 정교화 단계에서 평가됨

    function [7:0] my_function;
        input [7:0] n;
        begin
            my_function = n * 2; // 파라미터 계산 수행
        end
    endfunction
    ```
    ✔ 설명:

    - `my_function`은 정교화 단계에서 호출되어 파라미터 `size`를 계산합니다.

    - 시뮬레이션 시작 전에 모든 계산이 완료됩니다.

3. 시간 제어 불가
    ```verilog
    function [7:0] my_function;
        begin
            my_function = 8'd10; // 시간 제어 불가
        end
    endfunction
    ```

    ✔ 설명:

    - 상수 함수 내부에서는 시간 지연이나 사건 제어를 사용할 수 없습니다.